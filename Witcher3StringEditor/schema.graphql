schema {
  query: Query
  mutation: Mutation
}

"Autogenerated return type of AbstainFromModEndorsementMutation."
type AbstainFromModEndorsementMutationPayload {
  "Endorsement entry."
  endorsement: ModEndorsement!
  "Returns true when abstaining was successful."
  success: Boolean!
}

"Autogenerated return type of AcceptModerationFixMutation."
type AcceptModerationFixMutationPayload {
  "Return the moderation fix"
  moderationFix: ModerationFix!
  "Returns true if the fix was accepted successfully"
  success: Boolean!
}

"Autogenerated return type of AddBadgeToCollectionMutation."
type AddBadgeToCollectionMutationPayload {
  "True if badge was added to the collection"
  success: Boolean!
}

"Autogenerated return type of AddFavouriteGameMutation."
type AddFavouriteGameMutationPayload {
  "True if the favourite was successfully created"
  success: Boolean!
}

"Autogenerated return type of AddHeaderImageToCollectionMutation."
type AddHeaderImageToCollectionMutationPayload {
  "Header image that was added to the collection"
  image: CollectionImage!
}

"Autogenerated return type of AddImageToCollectionMutation."
type AddImageToCollectionMutationPayload {
  "Image that was added to the collection"
  image: CollectionImage!
}

"Autogenerated return type of AddTagToCollectionMutation."
type AddTagToCollectionMutationPayload {
  "True if all tags were added to the collection"
  success: Boolean!
}

"Autogenerated return type of AddTileImageToCollectionMutation."
type AddTileImageToCollectionMutationPayload {
  "Tile image that was added to the collection"
  image: CollectionImage!
}

"Autogenerated return type of AddVideoToCollectionMutation."
type AddVideoToCollectionMutationPayload {
  "Video that was added to the collection"
  video: CollectionVideo!
}

"An age verification ID and created at date pair."
type AgeVerificationId {
  "The date the external verification ID was created."
  createdAt: DateTime!
  "An external age verification ID."
  externalVerificationId: String!
}

"An age verification log entry for a user."
type AgeVerificationInfo {
  "An array of external age verification. Newest first."
  externalVerificationIds: [AgeVerificationId!]!
  "Indicates if the user has successfully verified their age."
  verified: Boolean!
}

"Autogenerated return type of AmendModerationMutation."
type AmendModerationMutationPayload {
  "Return Types::Objects::Moderation::ModerationType"
  moderation: Moderation!
  "Boolean determining success or failure of the request."
  success: Boolean!
}

"A modding application (or \"integration\") accessed with an API key"
type ApiApplication {
  "If true, this application is active"
  active: Boolean!
  "Application ID"
  id: ID!
  "Application image URL"
  image: String!
  "The API key for the logged in user, if one exists"
  key: String
  "Application name"
  name: String!
  "Machine-readable application name"
  slug: String!
  "Application summary"
  summary: String!
}

"An API key for a modding application (or \"integration\")"
type ApiKey implements Node {
  "The application which this key is for"
  applicationId: ID
  "ID of the object."
  id: ID!
  "The API key itself"
  key: String!
  "The user whose key this is"
  userId: Int!
}

"Application metric event"
type AppMetric {
  "Client identifier"
  clientString: String
  "When the metric was recorded"
  createdAt: ISO8601DateTime!
  "Unique identifier for the entity, e.g., collection ID"
  entityId: String!
  "Type of entity associated with the event, e.g., \"collection\""
  entityType: String!
  "Type of event that was tracked"
  eventType: AppMetricEventType!
  "Unique identifier for the metric event"
  id: BigInt!
  "Additional metadata as JSON object"
  metadata: JSON
  "ID of the user who triggered the event"
  userId: BigInt
}

"Application metric entity types"
enum AppMetricEntityType {
  "Collection"
  collection
}

"Application metric event types"
enum AppMetricEventType {
  "Collection installation completed"
  collection_completed
  "Collection installation started"
  collection_started
}

"Artwork schema using one tile image, additionally blurred for background use."
type ArtworkSchemaV1 {
  "URI template for primary game image."
  tile: String!
  "URI template for blurred image e.g. for background use."
  tileBlurred: String!
}

"Artwork schema introduced in May 2025, comprising tile, hero, and thumbnail images."
type ArtworkSchemaV2 {
  "URI template for hero e.g. for backgrounds, minimum 1920x620."
  hero: String!
  "URI template for thumbnail e.g. for icons, minimum 80x80."
  thumbnail: String!
  "URI template for tile e.g. for listings, minimum 400x267."
  tile: String!
}

"Something that can have files attached to it"
interface Attachable {
  "The attachment filename and IDs"
  attachments: [Attachment!]
}

"Type that exposes the attachment urls"
type Attachment implements Node {
  "The attachment filename"
  filename: String!
  "A unique ID for this attachment. This is a signed ID that will change between requests. This\nis expected behaviour and is to avoid tampering."
  id: ID!
  "The attachment URL"
  url: String!
}

"Average rating for a single revision and total number of votes"
type AverageRating {
  "Average rating for this revision"
  average: Float!
  "Number of positive votes"
  positive: Int!
  "Total number of votes"
  total: Int!
}

"A badge"
type Badge {
  "Whether the badge is automated."
  automated: Boolean!
  "Description of the badge."
  description: String!
  "ID of the badge."
  id: Int!
  "Name of the badge."
  name: String!
}

input BaseFilterValue {
  "Value"
  value: String!
  "Comparison operator for value."
  op: FilterComparisonOperator
}

input BaseFilterValueEqualsMatches {
  "Value"
  value: String!
  "Comparison operator for value."
  op: FilterComparisonOperatorEqualsMatches
}

input BaseFilterValueEqualsWildcard {
  "Value"
  value: String!
  "Comparison operator for value."
  op: FilterComparisonOperatorEqualsWildcard
}

input BaseFilterValueNumeric {
  "Value"
  value: String!
  "Comparison operator for value."
  op: FilterComparisonOperatorNumeric
}

input BaseSortValue {
  "Direction of sort."
  direction: SortDirection!
}

"Represents non-fractional signed whole numeric values. Since the value may exceed the size of a 32-bit integer, it's encoded as a string."
scalar BigInt

"Autogenerated return type of BlockModsFromEarningDpMutation."
type BlockModsFromEarningDpMutationPayload {
  "True if the mods were successfully blocked"
  success: Boolean!
}

"Autogenerated return type of BlockTagMutation."
type BlockTagMutationPayload {
  "If true, the tag is blocked."
  success: Boolean!
}

"Autogenerated return type of BlockUserMutation."
type BlockUserMutationPayload {
  "If true, the user is blocked."
  success: Boolean!
}

"A mod blocked from earning donation points"
type BlockedMod {
  "The database ID for this blocked_mod."
  id: String!
  "True if the mod is blocked from earning donation points"
  isBlocked: Boolean!
}

"A page of data"
type BlockedModsPage {
  "A list of entries"
  nodes: [BlockedMod!]!
  "Information about the page"
  pageInfo: BlockedModsPageInfo!
}

"Information about a page"
type BlockedModsPageInfo {
  "The total number of entries"
  totalCount: Int!
}

"A boolean value E.g. true or false"
input BooleanFilterValue {
  "Boolean Value"
  value: Boolean!
  "Comparison operator for value."
  op: FilterComparisonOperator
}

"Acceptable bug report closure reasons"
enum BugReportClosureReason {
  "None"
  none
  "Resolved"
  resolved
  "Not a bug"
  not_a_bug
  "Wont fix"
  wont_fix
}

"Moderation Status of a Bug Report"
enum BugReportModerationStatus {
  "None"
  none
  "Hidden"
  hidden
}

"Acceptable bug report statuses"
enum BugReportStatus {
  "Open"
  open
  "Closed"
  closed
}

"A category into which related entities may fall"
type Category {
  "Whether the category has been approved"
  approved: Boolean!
  "The id of the user who approved the category"
  approvedBy: Int
  "A list of games for which this category is used"
  categoryGames: [Game!]
  "Time of when this category was first created."
  createdAt: DateTime!
  "A brief description of the category's purpose"
  description: String!
  "Time of when this category was discarded."
  discardedAt: DateTime
  "The database ID for this category."
  id: Int!
  "The name of the category"
  name: String!
  "The id of the parent category"
  parentId: Int!
  "The id of the user who suggested the category"
  suggestedBy: Int!
  "Time of when this category was last updated."
  updatedAt: DateTime!
}

"Autogenerated return type of ChangeCollectionOwner."
type ChangeCollectionOwnerPayload {
  "Updated collection"
  collection: Collection!
  "Success Boolean"
  success: Boolean!
}

"Autogenerated return type of ClearCollectionBugReportModerationStatusMutation."
type ClearCollectionBugReportModerationStatusMutationPayload {
  "Collection bug report whose status was cleared"
  collectionBugReport: CollectionBugReport!
}

"Autogenerated return type of ClearCommentModerationStatusMutation."
type ClearCommentModerationStatusMutationPayload {
  "The comment that had its moderation status cleared."
  comment: Comment!
}

"Autogenerated return type of ClearThreadModerationStatusMutation."
type ClearThreadModerationStatusMutationPayload {
  "The comment thread that had its moderation status cleared."
  commentThread: CommentThread!
}

"Autogenerated return type of CloseCollectionBugReportMutation."
type CloseCollectionBugReportMutationPayload {
  "Collection bug report which was closed"
  collectionBugReport: CollectionBugReport!
}

"A curated collection of mods"
type Collection {
  "Indicates whether the collection contains adult content"
  adultContent: Boolean @deprecated(reason: "Adult content is now indicated at the revision level")
  "Whether to allow non-curator users to upload media"
  allowUserMedia: Boolean
  "Badges on the latest published revision"
  badges: [Badge!]
  "Fetch a bug report for this collection by its id"
  bugReport("The database ID for this bug report." bugReportId: ID!): CollectionBugReport!
  "A list of bug reports raised for the collection"
  bugReports("Filter bug reports by status. Possible opens are \"Open\" or \"Closed\"" status: BugReportStatus! "Column for sorting bug reports" sortBy: String "Direction for sorting bug reports" sortDirection: String "Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): CollectionBugReportConnection!
  "A category into which related entities may fall"
  category: Category
  "A list of changelogs created for the revisions of this collection"
  collectionChangelogs: [CollectionChangelog!]
  "Available collection statuses"
  collectionStatus: CollectionStatus
  "A link to the forum thread containing comments"
  commentLink: String
  "The comment thread for this collection."
  commentThread: CommentThread!
  "Time of when this collection was first created."
  createdAt: DateTime!
  "Latest published revision"
  currentRevision("Revision number" revision: Int): CollectionRevision! @deprecated(reason: "Deprecated in favour of using a 'collectionRevision' query")
  "A description of the collection in Markdown format"
  description: String!
  "A reason why the collection was discarded"
  discardReason: CollectionDiscardReason
  "Time of when this collection was discarded."
  discardedAt: DateTime
  "If there is a draft revision in this collection, this will return the revisionNumber\nfor that revision. If there are no draft revisions, this will simply be null"
  draftRevisionNumber: Int
  "Users who have permission to edit this collection."
  editors: [User!]
  "The number of endorsements given to the collection"
  endorsements: Int!
  "Time of when the first of this collection's revisions\nwas first published"
  firstPublishedAt: DateTime
  "The forum topic created to hold comments for this collection"
  forumTopic: ForumTopic @deprecated(reason: "Use `commentThread` instead.")
  "The game for which the collection was created"
  game: Game!
  "The id of the game for which the collection was created"
  gameId: Int!
  "The image used as the background of the header on the collection's page"
  headerImage: CollectionImage
  "The database ID for this collection."
  id: Int!
  "Time of when one of this collection's revisions\nwas last published"
  lastPublishedAt: DateTime
  "The latest published revision for this collection. This will be\nnull for collections with no published revisions"
  latestPublishedRevision: CollectionRevision
  "Rating of the latest published revision"
  latestPublishedRevisionRating: String
  "Time of when this collection was first listed"
  listedAt: DateTime
  "Whether uploaded media requires verification before being displayed"
  manuallyVerifyMedia: Boolean
  "A list of media uploaded to the collection, including images and videos"
  media: [CollectionMediaUnion!]!
  "Metadata information about a collection"
  metadata: CollectionMetadata
  "JWT token for submitting moderation reports"
  moderationJwt: String!
  "A list of moderation actions taken against this collection"
  moderations: [Moderation!]
  "The collection name"
  name: String!
  "An average taken from all revision ratings"
  overallRating: String
  "Total number of ratings given across all revisions"
  overallRatingCount: Int
  "The list of permissions granted to the requesting user against this collection."
  permissions: [Permission!]
  "Returns \"sanitized\" collection revisions. Safe to use with discarded revisions."
  publicRevisions: [PublicCollectionRevision!]
  "Time of when one of this collection's revisions\nwas last published"
  publishedAt: DateTime @deprecated(reason: "Use `last_published_at` instead.")
  "A 30 day average of all revision ratings"
  recentRating: String
  "Total number of ratings given in the last 30 days"
  recentRatingCount: Int
  "A list of revisions for the collection"
  revisions: [CollectionRevision!]!
  "A random string of characters identifying the collection. This is the identifier used in\na collection page url."
  slug: String!
  "A brief summary of the collection"
  summary: String!
  "A list of tags attached to the collection, used to surface the collection in search results"
  tags: [Tag!]!
  "The image used to identify the collection in list views"
  tileImage: CollectionImage
  "The total number of times this collection has been downloaded"
  totalDownloads: Int!
  "The total number of unique users who have downloaded this collection"
  uniqueDownloads: Int!
  "Time of when this collection was last updated."
  updatedAt: DateTime!
  "The curating user"
  user: User!
  "The id of the collection curator"
  userId: Int!
  "Whether the viewer has ignored the content owner."
  viewerBlocked: Boolean! @deprecated(reason: "Use `viewerHasIgnored` instead.")
  "Whether the viewer has ignored the content owner."
  viewerHasIgnored: Boolean!
  "Whether the viewer is blocked by the content owner."
  viewerIsBlocked: Boolean
}

"A collection bug report."
type CollectionBugReport implements Attachable {
  "The attachment filename and IDs"
  attachments: [Attachment!]
  "Date that this report was changed to closed"
  closedAt: DateTime
  "If closed, what was the reason for closing the report"
  closureReason: BugReportClosureReason
  "A curated collection of mods"
  collection: Collection!
  "The collection revision number."
  collectionRevisionNumber: Int!
  "The comment thread for this collection bug report."
  commentThread: CommentThread!
  "Date that this report was created"
  createdAt: DateTime!
  "User-provided summary of the Bug Report"
  description: String
  "User that hid this Bug Report from public view"
  hiddenBy: User
  "If hidden, this will provide a reason. This is intended for moderators, admins and\ncollection curators"
  hiddenInternalReason: String
  "If hidden, this will provide the reason"
  hiddenReason: String
  "The database ID for this collection bug report."
  id: ID!
  "JWT token for submitting moderation reports"
  moderationJwt: String!
  "If under moderation, can be none or hidden"
  moderationStatus: BugReportModerationStatus!
  "Date that this report was changed to open"
  openedAt: DateTime
  "Provides a list of all permissions for this report, using the context of the current user"
  permissions: [Permission!]
  "User that reported this Bug Report"
  reporter: User!
  "Status, can be Open or Closed"
  status: BugReportStatus!
  "Title of the bug report"
  title: String!
  "Date that this report was last updated"
  updatedAt: DateTime!
  "Whether the viewer has ignored the content owner."
  viewerHasIgnored: Boolean!
}

"The connection type for CollectionBugReport."
type CollectionBugReportConnection {
  "A list of edges."
  edges: [CollectionBugReportEdge]
  "A list of nodes."
  nodes: [CollectionBugReport]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Total # of objects returned from this Plural Query"
  totalCount: Int!
}

"An edge in a connection."
type CollectionBugReportEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CollectionBugReport
}

"A changelog attached to a collection revision"
type CollectionChangelog {
  "The id of the collection revision for which this changelog was created"
  collectionRevisionId: Int!
  "Time of when this collection changelog was first created."
  createdAt: DateTime!
  "The content of the collection changelog, in Markdown format"
  description: String!
  "The database ID for this collection changelog."
  id: Int!
  "The revision number of the collection revision for which this changelog was created"
  revisionNumber: Int!
  "Time of when this collection changelog was last updated."
  updatedAt: DateTime!
}

"A reason for which a revision has been retracted."
type CollectionDiscardReason {
  "The id of the collection which was discarded"
  collectionId: Int!
  "Time of when this collection discard reason was first created."
  createdAt: DateTime!
  "The database ID for this collection discard reason."
  id: Int!
  "The reason why the collection was discarded"
  reason: String!
  "Time of when this collection discard reason was last updated."
  updatedAt: DateTime!
}

input CollectionGeneralSearchFilterValue {
  "Value"
  value: String!
  "Comparison operator for value."
  op: FilterComparisonOperator
}

"Images related to a collection"
type CollectionImage implements GloballyIdentifiable & Reorderable {
  "The alt text describing the image for screen readers"
  altText: String
  "The collection for which the image was uploaded"
  collection: Collection!
  "Time of when this collection image was first created."
  createdAt: DateTime!
  "Time of when this collection image was discarded."
  discardedAt: DateTime
  "The global ID for this entity."
  globalId: ID
  "The database ID for this collection image."
  id: ID!
  "Determines where the image is displayed"
  imageType: ImageTypes!
  "The order of this entity in the list."
  order: String!
  "The collection revision for which the image was uploaded"
  revision: CollectionRevision
  "Can be used to select a scaled down\/compressed version of the image"
  thumbnailUrl("The thumbnail size" size: ThumbnailSize!): String!
  "The image title"
  title: String
  "Time of when this collection image was last updated."
  updatedAt: DateTime!
  "The image resource url"
  url: String!
  "The user who uploaded the image"
  user: User!
}

"The JSON manifest that defines a collection"
input CollectionManifest {
  "Manifest information"
  info: CollectionManifestInfo!
  "List of mod resources for the manifest"
  mods: [CollectionManifestMod!]!
}

"The info section of the JSON manifest"
input CollectionManifestInfo {
  "The collection author's name"
  author: String!
  "The url of the author's profile"
  authorUrl: String
  "The name of the collection"
  name: String!
  "A description of the collection"
  description: String
  "A short summary of the collection"
  summary: String
  "The domain name of the game"
  domainName: String!
  "A list of game versions that this revision has been tested with"
  gameVersions: [String!]
}

"Defines a mod to be used in a collection as part of the manifest"
input CollectionManifestMod {
  "The name of the mod"
  name: String!
  "The mod version"
  version: String!
  "Whether the mod is required for this collection"
  optional: Boolean!
  "The domain name of the game for the mod"
  domainName: String!
  "Mod source details"
  source: CollectionManifestModSource!
  "The name of the mod author"
  author: String
}

"Source information for a mod (nexus or other) as part of the manifest"
input CollectionManifestModSource {
  "Type of the mod source"
  type: ModSource!
  "Mod id"
  modId: Int
  "File ID"
  fileId: Int
  "An MD5 hash of the file for verification"
  md5: String
  "The file size in kb"
  fileSize: Int
  "Update policy type"
  updatePolicy: UpdatePolicy
  "Logical file name of the mod resource"
  logicalFilename: String
  "File expression of the mod resource"
  fileExpression: String
  "The direct url of the file"
  url: String
  "Does the mod includes adult content"
  adultContent: Boolean
}

"Collection Media"
union CollectionMediaUnion = CollectionImage | CollectionVideo

"Metadata information about a collection"
type CollectionMetadata {
  "A timestamp indicating the first time the user downloaded this collection"
  downloadedAt: DateTime
  "A positive value indicates an endorsement by the user, while a negative value\nindicates abstention (will be null if the user has not endorsed the collection)"
  endorsementValue: Int
  "The latest revision number downloaded by the user for this collection"
  latestDownloadedRevisionNumber: Int
}

type CollectionPage {
  "Facets available, if supported for this query and requested."
  facets: [NodesFacet!]
  "Facets available, if supported for this query and requested. Schema is {\"facetName\":{\"facetValue\":count}}"
  facetsData: JSON
  "Nodes for pagination"
  nodes: [Collection!]!
  "Number of nodes returned by this query"
  nodesCount: Int!
  "Facets available, if supported for this query and requested."
  nodesFacets: [NodesFacet!]
  "String representation of the filter query used to locate the nodes."
  nodesFilter: String
  "Total number of collections found."
  totalCount: Int!
}

"The data payload used to create a collection revision"
input CollectionPayload {
  "Whether the collection includes adult content"
  adultContent: Boolean!
  "Collection manifest"
  collectionManifest: CollectionManifest!
  "Collection schema ID (Default: 1)"
  collectionSchemaId: Int!
}

"An immutable revision of a collection"
type CollectionRevision {
  "If true, this revision could contain adult content and needs to be treated accordingly"
  adultContent: Boolean!
  "The size of bundled assets within the revision in bytes"
  assetsSizeBytes: BigInt!
  "Badges associated with this collection revision"
  badges: [Badge!]!
  "Gets the collection that this revision belongs to. This will ignore adult_content flags."
  collection: Collection!
  "A changelog attached to a collection revision"
  collectionChangelog: CollectionChangelog
  "The database ID for this collection."
  collectionId: Int!
  "A model of the expected structure for a collection manifest"
  collectionSchema: CollectionSchema!
  "The database ID for this collection schema."
  collectionSchemaId: Int!
  "The link to generate a content preview for the revision"
  contentPreviewLink: String!
  "Time of when this revision was first created."
  createdAt: DateTime!
  "Time of when this revision was discarded."
  discardedAt: DateTime
  "The download link for the revision"
  downloadLink: String!
  "Array of external resources referenced by this revision"
  externalResources: [ExternalResource!]!
  "The total size of the revision in bytes"
  fileSize: BigInt! @deprecated(reason: "Use \"totalSize\" instead.")
  "A list of game versions for which the revision has been confirmed to work (usually the\ngame version for which the revision was created)"
  gameVersions: [GameVersion!]
  "The database ID for this revision."
  id: Int!
  "Additional information about the installation process of this revision"
  installationInfo: String
  "Will be true if the revision is the latest published for the collection"
  latest: Boolean!
  "Metadata information about a collection revision"
  metadata: CollectionRevisionMetadata
  "List of authors of the mods included in this revision ordered (DESC) by the number of\nmods in the revision."
  modAuthors("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): UserConnection!
  "The number of mods and external resources in this collection"
  modCount: Int!
  "A list of mod files included in the revision"
  modFiles: [CollectionRevisionMod!]!
  "An average taken from all ratings for this revision"
  overallRating: String
  "A count of all ratings for this revision"
  overallRatingCount: Int
  "Average rating for a single revision and total number of votes"
  rating: AverageRating! @deprecated(reason: "Deprecated in favour of 'overallRating' and 'overallRatingCount'")
  "A reason for which a revision has been retracted."
  retractionReason: RetractionReason
  "The revision number"
  revision: Int! @deprecated(reason: "Use \"revisionNumber\" instead.")
  "The revision number"
  revisionNumber: Int!
  "The status of this revision. Possible values are 'draft', 'published' or 'retracted'"
  revisionStatus: String!
  "The status of this revision. Possible values are 'draft', 'published' or 'retracted'"
  status: String!
  "The total number of times the revision has been downloaded"
  totalDownloads: Int!
  "The total size of the revision in bytes"
  totalSize: BigInt!
  "The number of unique users who have download the revision"
  uniqueDownloads: Int!
  "Time of when this revision was last updated."
  updatedAt: DateTime!
}

"Metadata information about a collection revision"
type CollectionRevisionMetadata {
  "A timestamp indicating the first time the user downloaded this revision"
  downloadedAt: DateTime
  "Indicates the rating given by the user to a revision"
  ratingValue: RatingOptions
}

"A mod file included in a collection"
type CollectionRevisionMod {
  "The id of the collection revision including the mod file"
  collectionRevisionId: Int!
  "The mod file"
  file: ModFile
  "The mod file's id"
  fileId: Int!
  "The game id for the mod file"
  gameId: Int!
  "The database ID for this collection revision mod."
  id: ID!
  "Whether the mod file is required for the collection"
  optional: Boolean!
  "Indicates to mod managers how they should handle automatic updates"
  updatePolicy: String!
  "The mod file version"
  version: String!
}

"A model of the expected structure for a collection manifest"
type CollectionSchema {
  "Time of when this collection schema was first created."
  createdAt: DateTime!
  "The database ID for this collection schema."
  id: Int!
  "Time of when this collection schema was last updated."
  updatedAt: DateTime!
  "Schema version for the collection manifest format"
  version: String!
}

"Available collection statuses"
enum CollectionStatus {
  "Publicly visible"
  listed
  "Does not appear in lists"
  unlisted
  "Under moderation"
  under_moderation
  "Discarded"
  discarded
}

"Videos related to a collection"
type CollectionVideo implements GloballyIdentifiable & Reorderable {
  "Collection that this video belongs to"
  collection: Collection!
  "Time of when this collection video was first created."
  createdAt: DateTime!
  "Time of when this collection video was discarded."
  discardedAt: DateTime
  "The global ID for this entity."
  globalId: ID
  "The database ID for this collection video."
  id: ID!
  "The order of this entity in the list."
  order: String!
  "Revision that this video belongs to"
  revision: CollectionRevision
  "The thumbnail URL for the video."
  thumbnailUrl: String!
  "The title of the video."
  title: String!
  "Time of when this collection video was last updated."
  updatedAt: DateTime!
  "URL of this video"
  url: String!
  "Uploader of this video"
  user: User!
}

"Facet fields specific to the Collections query."
input CollectionsFacet {
  "Facet on adult content."
  adultContent: [String!]
  "Facet on category."
  categoryName: [String!]
  "Facet on ratings."
  collectionRating: [String!]
  "Facet on status."
  collectionStatus: [String!]
  "Facet on game name."
  gameName: [String!]
  "Facet on game ID."
  gameIds: [String!]
  "Facet on game versions."
  gameVersion: [String!]
  "Facet on collection tags."
  tag: [String!]
  "Facet on collection badges."
  badges: [String!]
}

"Common filter fields specific to the Collections query"
input CollectionsFilter {
  "Nested filters."
  filter: [CollectionsFilter!]
  "Logical operator for clauses."
  op: FilterLogicalOperator
  "Collection Name"
  name: [BaseFilterValue!]
  "Collection Rating"
  collectionRating: [BaseFilterValue!]
  "Status of the collection. Valid values are: \"unlisted\",\n\"under_moderation\" (moderators\/admins only), \"discarded\" (moderators\/admins only)."
  collectionStatus: [BaseFilterValue!]
  "Game ID"
  gameId: [BaseFilterValue!]
  "Game domain name E.g. skyrim"
  gameDomain: [BaseFilterValue!]
  "Game name E.g. Skyrim"
  gameName: [BaseFilterValue!]
  "Category ID"
  categoryId: [BaseFilterValue!]
  "Category name"
  categoryName: [BaseFilterValue!]
  "Filter collections for specific game versions"
  gameVersion: [BaseFilterValue!]
  "The mod unique identifier."
  modUid: [BaseFilterValue!]
  "The tag name, exact match."
  tag: [BaseFilterValue!]
  "Whether to show adult content in search results"
  adultContent: [BooleanFilterValue!]
  "Only show collections that have a draft revision"
  hasDraftRevision: [BooleanFilterValue!]
  "Only show collections that have a published revision"
  hasPublishedRevision: [BooleanFilterValue!]
  "Text search on name, summary and description, partial match."
  generalSearch: [CollectionGeneralSearchFilterValue!]
}

"Common filter fields specific to the Collections query"
input CollectionsSearchFilter {
  "Nested filters."
  filter: [CollectionsSearchFilter!]
  "Logical operator for clauses."
  op: FilterLogicalOperator
  "Author ID"
  userId: [BaseFilterValue!]
  "Collection Name"
  name: [BaseFilterValue!]
  "Collection Rating"
  collectionRating: [BaseFilterValue!]
  "A 30 day average of all revision ratings"
  recentRating: [FloatFilterValue!]
  "Total number of ratings given in the last 30 days"
  recentRatingCount: [IntFilterValue!]
  "Created at date"
  createdAt: [BaseFilterValue!]
  "Updated at date"
  updatedAt: [BaseFilterValue!]
  "Collection Status"
  collectionStatus: [BaseFilterValue!]
  "Game ID"
  gameId: [BaseFilterValue!]
  "Game domain name E.g. skyrim"
  gameDomain: [BaseFilterValue!]
  "Game name E.g. Skyrim"
  gameName: [BaseFilterValue!]
  "Category ID"
  categoryId: [BaseFilterValue!]
  "Category name"
  categoryName: [BaseFilterValue!]
  "Filter collections for specific game versions"
  gameVersion: [BaseFilterValue!]
  "The mod unique identifier."
  modUid: [BaseFilterValue!]
  "The tag name, exact match."
  tag: [BaseFilterValue!]
  "Whether to show adult content in search results"
  adultContent: [BooleanFilterValue!]
  "Only show collections that have a draft revision"
  hasDraftRevision: [BooleanFilterValue!]
  "Only show collections that have a published revision"
  hasPublishedRevision: [BooleanFilterValue!]
  "Text search on name, summary and description, partial match."
  generalSearch: [CollectionGeneralSearchFilterValue!]
}

"Sort fields specific to a Collections query."
input CollectionsSearchSort {
  "Filter query relevance, works best with non wildcard queries."
  relevance: BaseSortValue
  "Created at date"
  createdAt: BaseSortValue
  "Updated at date"
  updatedAt: BaseSortValue
  "Endorsements count"
  endorsements: BaseSortValue
  "Downloads count"
  downloads: BaseSortValue
  "Overall rating"
  rating: BaseSortValue
  "Recent rating"
  recentRating: BaseSortValue
}

"A comment."
type Comment implements Attachable {
  "The attachment filename and IDs"
  attachments: [Attachment!]
  "The content of the latest revision for this comment."
  body: String!
  "Time of when this comment was first created."
  createdAt: DateTime!
  "The user that created this comment."
  creator: User!
  "The pagination cursor for this comment."
  cursor: String!
  "Time of when this comment was discarded."
  discardedAt: DateTime
  "The user that discarded this comment."
  discardedBy: User
  "Time of when this comment was hidden."
  hiddenAt: DateTime
  "The user that hid this comment."
  hiddenBy: User
  "The internal reason why this comment was hidden. Only accessible to admins and moderators."
  hiddenInternalReason: String
  "The public reason why this comment was hidden."
  hiddenReason: String
  "The database ID for this comment."
  id: ID!
  "Returns a boolean indicating whether this comment is discarded."
  isDiscarded: Boolean!
  "Is this a pinned comment"
  isPinned: Boolean!
  "Comment likes count."
  likesCount: Int!
  "Time of when this comment was locked."
  lockedAt: DateTime
  "The user that locked this comment."
  lockedBy: User
  "Returns a boolean indicating whether this comment was moderated by an admin."
  moderatedByAdmin: Boolean!
  "JWT token for submitting moderation reports"
  moderationJwt: String!
  "The moderation status of this comment."
  moderationStatus: CommentModerationStatus!
  "The parent comment."
  parent: Comment
  "The user that pinned this comment."
  pinPriority: Int
  "User which pinned the comment"
  pinnedBy: User
  "Returns a boolean indicating whether this comment was pinned by an admin."
  pinnedByAdmin: Boolean!
  "A list of replies to this comment."
  replies("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): CommentConnection!
  "The revisions of this comment."
  revisions: [CommentRevision!]!
  "Time of when this comment was last updated."
  updatedAt: DateTime!
  "Whether the viewer has ignored the content owner."
  viewerHasIgnored: Boolean!
  "Returns a boolean indicating whether the viewing user has liked this comment."
  viewerHasLiked: Boolean!
}

"The connection type for Comment."
type CommentConnection {
  "A list of edges."
  edges: [CommentEdge]
  "A list of nodes."
  nodes: [Comment]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Total # of objects returned from this Plural Query"
  totalCount: Int!
}

"An edge in a connection."
type CommentEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Comment
}

"Enum for available moderation states: \"none\", \"hidden\", \"locked\""
enum CommentModerationStatus {
  "The comment is not under moderation."
  none
  "The comment cannot be viewed."
  hidden
  "The comment cannot be interacted with."
  locked
}

"A comment revision."
type CommentRevision implements Node {
  "The content of this revision."
  body: String!
  "Time of when this revision was first created."
  createdAt: DateTime!
  "ID of the object."
  id: ID!
  "Time of when this revision was last updated."
  updatedAt: DateTime!
}

"The connection type for Comment."
type CommentSearchResultConnection {
  "A list of edges."
  edges: [CommentSearchResultEdge]
  "A list of nodes."
  nodes: [Comment]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Time taken to complete the search in milliseconds."
  timeTaken: Int!
  "Total number of results."
  totalCount: Int!
}

"A comment search result edge."
type CommentSearchResultEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Comment
  "The relevancy score of the result. Higher scores mean more relevance."
  relevance: Float!
}

"A comment thread."
type CommentThread {
  "Look up comments."
  comments("Sort results by" sortBy: String "Sort direction" sortDirection: String "Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): CommentConnection!
  "The database ID for this comment thread."
  id: ID!
  "Time of when this comment thread was locked."
  lockedAt: DateTime
  "The user that locked this comment thread."
  lockedBy: User
  "Returns a boolean indicating whether this comment thread was moderated by an admin."
  moderatedByAdmin: Boolean!
  "The moderation status of this comment thread."
  moderationStatus: CommentThreadModerationStatus!
  "The thread owner"
  owner: User!
}

"Enum for available thread moderation states: \"none\", \"locked\""
enum CommentThreadModerationStatus {
  "The comment thread is not under moderation."
  none
  "The comment thread cannot be interacted with."
  locked
}

"Filter fields specific to the comments search query."
input CommentsSearchFilter {
  "Nested filters."
  filter: [CommentsSearchFilter!]
  "Logical operator for clauses."
  op: FilterLogicalOperator
  "Full text search query."
  query: [BaseFilterValue!]
  "The ID of the comment thread to search within."
  threadId: [BaseFilterValue!]
}

"Sort fields specific to the comments search query."
input CommentsSearchSort {
  "Sort by most relevant first."
  relevance: BaseSortValue
}

"Defines a Mod request using Game Domain and Mod ID"
input CompositeDomainWithIdInput {
  "Game domain"
  gameDomain: String!
  "Mod ID"
  modId: Int!
}

"Defines a Mod request using Game ID and Mod ID"
input CompositeIdInput {
  "Game ID"
  gameId: Int!
  "Mod ID"
  modId: Int!
}

"Autogenerated return type of CreateApiKeyMutation."
type CreateApiKeyMutationPayload {
  "The created key"
  apiKey: ApiKey!
  "True if the key was successfully created"
  success: Boolean!
}

"Autogenerated return type of CreateChangelogMutation."
type CreateChangelogMutationPayload {
  "Updated changelog ID"
  changelogId: Int!
  "Success Boolean"
  success: Boolean!
}

"Autogenerated return type of CreateCollectionBugReportMutation."
type CreateCollectionBugReportMutationPayload {
  "Collection bug report that was created"
  collectionBugReport: CollectionBugReport!
}

"Autogenerated return type of CreateCollectionMutation."
type CreateCollectionMutationPayload {
  "Returns created collection"
  collection: Collection!
  "The database ID for this collection."
  collectionId: Int!
  "Returns the collection revision which is created alongside the collection"
  revision: CollectionRevision!
  "The database ID for this collection revision."
  revisionId: Int!
  "Returns true when collection is successfully created."
  success: Boolean!
}

"Autogenerated return type of CreateCommentMutation."
type CreateCommentMutationPayload {
  "The comment that was created."
  comment: Comment!
}

"Autogenerated return type of CreateCsamDeletionRequest."
type CreateCsamDeletionRequestPayload {
  "The created CSAM Deletion Request"
  csamDeletionRequest: CsamDeletionRequest
}

"Autogenerated return type of CreateEndorsementMutation."
type CreateEndorsementMutationPayload {
  "Endorsement entry."
  endorsement: Endorsement!
  "Returns true when endorsement is created successfully."
  success: Boolean!
}

"Autogenerated return type of CreateMessage."
type CreateMessagePayload {
  "Returns true when message was sent."
  success: Boolean!
}

"Autogenerated return type of CreateModEndorsementMutation."
type CreateModEndorsementMutationPayload {
  "Endorsement entry."
  endorsement: ModEndorsement!
  "Returns true when endorsement is created successfully."
  success: Boolean!
}

"Autogenerated return type of CreateNoteAboutUserMutation."
type CreateNoteAboutUserMutationPayload {
  "Moderation note created successfully"
  success: Boolean
}

"Autogenerated return type of CreateOrUpdateRevisionMutation."
type CreateOrUpdateRevisionMutationPayload {
  "Return the collection that was updated"
  collection: Collection!
  "The database ID for this collection."
  collectionId: Int!
  "Return the revision that was updated"
  revision: CollectionRevision!
  "The database ID for this revision."
  revisionId: Int!
  "The revision number"
  revisionNumber: Int!
  "Return true if the revision was updated"
  success: Boolean!
}

"Autogenerated return type of CreateRatingMutation."
type CreateRatingMutationPayload {
  "Average rating value of the entity the rating was created for."
  averageRating: AverageRating!
  "Rating entry."
  rating: Rating!
  "Returns true when rating is created successfully."
  success: Boolean!
}

"Autogenerated return type of CreateTagMutation."
type CreateTagMutationPayload {
  "Success Boolean"
  success: Boolean!
  "Created Tag"
  tag: Tag
}

"A CSAM Deletion Request"
type CsamDeletionRequest {
  "Timestamp when the request was created"
  createdAt: DateTime!
  "List of CSAM URL IDs to be deleted"
  csamUrls: String!
  "ID of the CSAM Deletion Request"
  id: ID!
  "ID of the user who made the request"
  requesterMemberId: ID!
  "Current status of the request"
  status: CsamDeletionRequestStatus!
}

"A CSAM Deletion Request file path result from a CDN"
input CsamDeletionRequestCDNFilePathResult {
  "The file path that was processed"
  path: String!
  "The status of the file path processing (e.g., \"deleted\", \"failed\", \"not_found\")"
  status: String!
  "A message about the processing of the file path"
  message: String!
}

"A CSAM Deletion Request status update from a CDN"
input CsamDeletionRequestCDNResult {
  "CDN hostname"
  hostname: String!
  "Timestamp when the CDN processed the request"
  processedAt: DateTime!
  "A summary of the results from a CSAM Deletion Request processed by a CDN"
  summary: CsamDeletionRequestCDNSummary!
  "List of individual URL deletion results"
  results: [CsamDeletionRequestCDNUrlResult!]!
}

"A summary of the results from a CSAM Deletion Request processed by a CDN"
input CsamDeletionRequestCDNSummary {
  "Total number of URLs processed by the CDN"
  total: Int!
  "Number of URLs successfully"
  succeeded: Int!
  "Number of URLs that failed to be deleted by the CDN"
  failed: Int!
}

"A CSAM Deletion Request status update for a url from a CDN"
input CsamDeletionRequestCDNUrlResult {
  "The URL that was processed by the CDN"
  url: String!
  "Whether the URL was successfully processed"
  success: Boolean!
  "A message from the CDN about the processing of the URL"
  message: String!
  "List of file paths that were processed for this URL"
  filePaths: [CsamDeletionRequestCDNFilePathResult!]!
  "Number of file paths found for this URL"
  foundCount: Int!
  "Number of file paths successfully deleted for this URL"
  deletedCount: Int!
  "Number of file paths that failed to be deleted for this URL"
  failedCount: Int!
}

"Status of a CSAM Deletion Request"
enum CsamDeletionRequestStatus {
  PENDING
  IN_PROGRESS_BACKBLAZE
  IN_PROGRESS_CDN
  IN_PROGRESS_CLOUDFLARE_CACHE
  COMPLETED_SUCCESSFULLY
  COMPLETED_WITH_FAILURES
}

"Scalar Type to parse and handle DateTimes in iso8601 format"
scalar DateTime

"Autogenerated return type of DeleteApiKeyMutation."
type DeleteApiKeyMutationPayload {
  "Output message"
  message: String
  "True if the key was successfully removed"
  success: Boolean!
}

"Autogenerated return type of DeletePersonalApiKeyMutation."
type DeletePersonalApiKeyMutationPayload {
  "Output message"
  message: String
  "True if the key was successfully removed"
  success: Boolean!
}

"Autogenerated return type of DiscardCollectionMutation."
type DiscardCollectionMutationPayload {
  "Success Boolean"
  success: Boolean!
}

"Autogenerated return type of DiscardCommentMutation."
type DiscardCommentMutationPayload {
  "The comment that was discarded."
  comment: Comment!
}

"Autogenerated return type of DiscardRevisionMutation."
type DiscardRevisionMutationPayload {
  "Success Boolean"
  success: Boolean!
}

"Autogenerated return type of DiscardTagMutation."
type DiscardTagMutationPayload {
  "Returns true if tag was discarded"
  success: Boolean!
}

"Report Type defined by the Wallet app."
enum DonationReport {
  "Unique Download report"
  UNIQUE_DOWNLOADS
  "Interaction-based, game-adjusted report"
  I20_GAME_ADJUSTED
  "Interaction-based report with DP bucketed by game"
  I20_GAME_POOLS
}

"Autogenerated return type of EditCollectionMutation."
type EditCollectionMutationPayload {
  "Return collection object"
  collection: Collection!
  "Returns true if collection was updated"
  success: Boolean!
}

"An Endorsement"
type Endorsement {
  "Id of endorsed entity"
  modelId: BigInt!
  "Type of endorsed entity"
  modelType: String!
  "Endorsement status: abstained\/endorsed"
  status: String!
  "The database ID for this endorsement."
  userId: Int!
}

"A mod file that is not hosted on Nexus Mods"
type ExternalResource {
  "Similar to the author field in the mod details. So this is not\nthe uploader and may not be an actual user account on the page. Will often be unassigned for external resources"
  author: String
  "The database ID for this revision."
  collectionRevisionId: Int!
  "Glob pattern that must then match the archive file name. In cases where the collection asks\nfor a non-exact version (e.g.: 1.2.4 or newer) where we can't look at the hash of the expected file, this can be used\nto determine if the mod is already installed\/downloaded locally."
  fileExpression: String!
  "The database ID for this external resource."
  id: Int!
  "Deprecated"
  instructions: String @deprecated(reason: "This field is no longer being used")
  "Name of this resource"
  name: String!
  "If true, this is an optional resource"
  optional: Boolean!
  "Resource type. This can be one of \"direct\" (A url to\ndownload directly from), \"browse\" (A website url for the user to browse and manually select the right file on), \"manual\"\n (Vortex will just show instructions for the user to create\/acquire the mod manually)."
  resourceType: String!
  "Only set in the \"browse\"\/\"direct\" types, contains the url\nto browse to\/download from"
  resourceUrl: String
  "The version of the mod that the curator had installed at the\ntime of uploading the collection."
  version: String
}

"An external video."
type ExternalVideo {
  "The embed URL for the video."
  embedUrl: String!
  "The external video ID."
  id: ID!
  "The platform where the video is hosted."
  platform: ExternalVideoPlatform!
  "The thumbnail URL for the video."
  thumbnailUrl: String!
  "The title of the video."
  title: String!
}

"Supported external video platforms."
enum ExternalVideoPlatform {
  "https:\/\/www.youtube.com"
  youtube
}

"A Mod File Hash"
type FileHash {
  "Time of when this file was first created."
  createdAt: DateTime!
  "Name of the file"
  fileName: String!
  "Filesize in bytes"
  fileSize: BigInt!
  "Type of file"
  fileType: String!
  "The database ID for this game."
  gameId: Int!
  "MD5 Checksum of the file"
  md5: String!
  "Mod file object"
  modFile: ModFile
  "The database ID for this file."
  modFileId: Int!
}

"Filter comparison operators for elastic search queries."
enum FilterComparisonOperator {
  EQUALS
  NOT_EQUALS
  "Matches if all terms in the value are present (in any order). No wildcarding, though stems may match."
  MATCHES
  "Matches if all terms in the value are present (in any order), with leading\/trailing wildcards applied."
  WILDCARD
  "Greater than"
  GT
  "Greater than or equal to"
  GTE
  "Less than"
  LT
  "Less than or equal to"
  LTE
}

"Filter comparison equals and matches operators for elastic search queries."
enum FilterComparisonOperatorEqualsMatches {
  EQUALS
  NOT_EQUALS
  "Matches if all terms in the value are present (in any order). No wildcarding, though stems may match."
  MATCHES
}

"Filter comparison equals and matches operators for elastic search queries."
enum FilterComparisonOperatorEqualsWildcard {
  EQUALS
  NOT_EQUALS
  "Matches if all terms in the value are present (in any order), with leading\/trailing wildcards applied."
  WILDCARD
}

"Filter comparison equals and matches operators for elastic search queries."
enum FilterComparisonOperatorNumeric {
  EQUALS
  NOT_EQUALS
  "Greater than"
  GT
  "Greater than or equal to"
  GTE
  "Less than"
  LT
  "Less than or equal to"
  LTE
}

"Filter logical operators for elastic search queries."
enum FilterLogicalOperator {
  "Logical AND"
  AND
  "Logical OR"
  OR
}

"A float value"
input FloatFilterValue {
  "Float Value"
  value: Float!
  "Comparison operator for value."
  op: FilterComparisonOperator
}

"Formal or informal moderation warning"
enum FormalOrInformalWarning {
  INFORMAL_WARNING
  FORMAL_WARNING
}

"A forum post"
type ForumPost {
  "Author ID of the forum post"
  authorId: Int!
  "Author name of the forum post"
  authorName: String!
  "The database ID for this forum post."
  id: Int!
  "Post contents"
  post: String!
  "Post date and time"
  postDate: Int!
  "Post author details"
  user: User!
}

"A forum topic"
type ForumTopic {
  "If true, this topic has been approved"
  approved: Boolean!
  "Description"
  description: String!
  "The database ID for this forum."
  forumId: Int!
  "The database ID for this forum topic."
  id: Int!
  "If true, this topic is pinned and should appear above all\nnon-pinned topics"
  pinned: Boolean!
  "List of all posts within this topic"
  posts: [ForumPost!]
  "Number of posts in the topic"
  postsCount: Int!
  "State of this topic, can be open or closed"
  state: String!
  "Title for this topic"
  title: String!
  "SEO-specific title for this topic"
  titleSeo: String!
  "URL for this topic"
  topicUrl: String
  "Number of views this topic has received"
  views: Int!
  "TODO"
  visible: String!
}

"A Game"
type Game {
  "Time that this game was approved, after being submitted by a community member"
  approvedAt: DateTime
  "Schema for game artwork (V1 for game tile only, V2 for multiple artwork assets)."
  artworkSchema: GameArtworkSchema
  "Tags available for collections under this specific game, including global tags."
  availableTags: [Tag!]
  "Number of collections within this game"
  collectionCount: Int
  "True if the name of this game is a copyrighted asset"
  copyrightedName: Boolean!
  "Nexus-specific domain name, used to separate games on the Nexus Mods website."
  domainName: String!
  "Number of total downloads for mods in this game"
  downloadCount: BigInt
  "URL to the game's forum"
  forumUrl: String
  "Genre of this game"
  genre: String
  "The database ID for this game."
  id: Int!
  "Number of uploaded images within this game"
  imageCount: Int
  "Number of uploaded images, supporter images, and videos within this game"
  mediaCount: Int
  "Number of mods within this game"
  modCount: Int
  "Name of this game"
  name: String!
  "Tags only available for collections under this specific game."
  specificTags: [Tag!]
  "Number of uploaded supporter images within this game"
  supporterImageCount: Int
  "Number of days to consider for trending mods"
  trendingPeriodDays: Int!
  "Number of total unique downloads for mods in this game"
  uniqueDownloadCount: BigInt
  "Number of uploaded videos within this game"
  videoCount: Int
}

"Game artwork is set individually. This describes the schema for the artwork."
type GameArtwork {
  "V1 prior to May 2025, using one tile image."
  schemaV1: ArtworkSchemaV1!
  "V2 introduced May 2025, comprising tile, hero, and thumbnail images."
  schemaV2: ArtworkSchemaV2!
}

"Schema for managing game artwork"
enum GameArtworkSchema {
  V1
  V2
}

"The connection type for Game."
type GameConnection {
  "A list of edges."
  edges: [GameEdge]
  "A list of nodes."
  nodes: [Game]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Total # of objects returned from this Plural Query"
  totalCount: Int!
}

"An edge in a connection."
type GameEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Game
}

"Represents a game expansion (DLC)"
type GameExpansion {
  "The ID of the game that the expansion belongs to"
  gameId: ID!
  "The ID of the game expansion"
  id: ID!
  "The name of the game expansion"
  name: String!
}

input GameNameFieldFilterValue {
  "Value"
  value: String!
  "Comparison operator for value."
  op: FilterComparisonOperator
}

type GamePage {
  "Facets available, if supported for this query and requested."
  facets: [NodesFacet!]
  "Facets available, if supported for this query and requested. Schema is {\"facetName\":{\"facetValue\":count}}"
  facetsData: JSON
  "Nodes for pagination"
  nodes: [Game!]!
  "Number of nodes returned by this query"
  nodesCount: Int!
  "Facets available, if supported for this query and requested."
  nodesFacets: [NodesFacet!]
  "String representation of the filter query used to locate the nodes."
  nodesFilter: String
  "Total number of collections found."
  totalCount: Int!
}

"A version of a specific game."
type GameVersion {
  "Unique ID for referring to this version in future queries"
  id: ID!
  "Game version reference"
  reference: String!
}

"Facet fields specific to the games query."
input GamesFacet {
  "Facet on game genre."
  genre: [String!]
  "Facet on collections."
  hasCollections: [String!]
  "Facet on Vortex support."
  supportsVortex: [String!]
}

"Filter for a list of Games"
input GamesSearchFilter {
  "Nested filters."
  filter: [GamesSearchFilter!]
  "Logical operator for clauses."
  op: FilterLogicalOperator
  "Game name suitable for use with op:wildcard, but not op:matches. Punctuation matched."
  name: [GameNameFieldFilterValue!]
}

"Sort for a list of Games"
input GamesSearchSort {
  "Number of downloads."
  downloads: BaseSortValue
  "Number of mods."
  mods: BaseSortValue
  "Number of collections."
  collections: BaseSortValue
  "Game name."
  name: BaseSortValue
  "Date approved."
  approved: BaseSortValue
  "Filter query relevance."
  relevance: BaseSortValue
}

"Autogenerated return type of GiveKudosMutation."
type GiveKudosMutationPayload {
  "True if the user was successfully given kudos"
  success: Boolean!
}

"A sitewide notice to be displayed to all users"
type GlobalNotice {
  "Content of the notice"
  content: String!
  "Date of the notice"
  date: DateTime!
  "Staff member who created the notice"
  staff: User!
}

"A globally identifiable entity."
interface GloballyIdentifiable {
  "The global ID for this entity."
  globalId: ID
  "ID of the object."
  id: ID!
}

"Result of checking an MD5 hash against the CSAM known image hashlist"
type HashCheckResult {
  "The MD5 hash that was checked"
  hashValue: String!
  "Whether the hash was found in the CSAM hashlist (true = match found, false = no match)"
  match: Boolean!
}

"Autogenerated return type of HideCollectionBugReportMutation."
type HideCollectionBugReportMutationPayload {
  "Collection bug report which was hidden"
  collectionBugReport: CollectionBugReport!
}

"Autogenerated return type of HideCommentMutation."
type HideCommentMutationPayload {
  "The comment that was hidden."
  comment: Comment!
}

"An ISO 8601-encoded datetime"
scalar ISO8601DateTime

"Autogenerated return type of IgnoreUserMutation."
type IgnoreUserMutationPayload {
  "If true, the user is blocked."
  success: Boolean!
}

"An image"
type Image implements Node {
  "If true, this image contains adult content"
  adult: Boolean
  "Whether comments are allowed on the image."
  allowComments: Boolean
  "Whether ratings are allowed on the image."
  allowRating: Boolean
  "A caption for this image"
  caption: String!
  "An image category"
  category: ImageCategory!
  "Time of when this image was first created."
  createdAt: DateTime!
  "A detailed description of this image"
  description: String!
  "Game this image belongs to"
  game: Game!
  "ID of the object."
  id: ID!
  "Status of this image"
  mediaStatus: MediaStatus!
  "Name of the image file"
  name: String!
  "Uploader of this image"
  owner: User!
  "Rating of this image"
  rating: Int!
  "URL of the site this image is hosted on"
  siteUrl: String!
  "URL of the thumbnail of this image"
  thumbnailUrl: String!
  "A title for this image"
  title: String
  "URL of this image"
  url: String!
  "True if the viewer (current user) has ignored this image's author"
  viewerBlocked: Boolean!
  "View count of this image"
  views: Int!
}

"An image category"
type ImageCategory {
  "Unix timestamp of category creation"
  date: Int
  "The database ID for this game."
  gameId: Int!
  "The database ID for this image category."
  id: ID!
  "Name of this category"
  name: String!
}

"Available image types"
enum ImageTypes {
  gallery
  tile
  header
}

"An integer value"
input IntFilterValue {
  "Integer Value"
  value: Int!
  "Comparison operator for value."
  op: FilterComparisonOperator
}

"Autogenerated return type of IssueWarningToUserMutation."
type IssueWarningToUserMutationPayload {
  "Warning issued successfully"
  success: Boolean
}

"Represents untyped JSON"
scalar JSON

"A Tag"
type LegacyTag implements Node {
  "If true, this tag is blockable by the user"
  blockable: Boolean!
  "Games this\ntag is used for. Will be nil if global is true, as this tag would apply to all games"
  games("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): GameConnection
  "If true, this Tag is global and not intended for a specific game"
  global: Boolean!
  "ID of this tag"
  id: ID!
  "Name of this tag"
  name: String!
  "ID of the parent tag, if any"
  parentId: ID
  "If true, this tag can be searched on by users"
  searchable: Boolean!
}

"Autogenerated return type of LegacyUpdateModerationWarningMutation."
type LegacyUpdateModerationWarningMutationPayload {
  "Moderation warning updated successfully"
  success: Boolean
}

"Autogenerated return type of LegacyUpdatePreferencesMutation."
type LegacyUpdatePreferencesMutationPayload {
  "User preferences updated successfully"
  success: Boolean
}

"A set of user donation preferences."
type LegacyUserDonationPreferences implements Node {
  "Whether the user has enabled author premium donations."
  donateAuthorpremium: Boolean!
  "Whether the user has enabled own premium donations."
  donateOwnpremium: Boolean!
  "The maximum amount of premium time in months a user can donate (0 is Lifetime, or no limit)."
  donatePremiumMax: Int!
  "Whether the user has enabled profile donations."
  donateProfile: Boolean!
  "Whether the user has enabled straight donations."
  donateStraight: Boolean!
  "ID of the object."
  id: ID!
  "The user's PayPal email address."
  paypal: String!
}

"Autogenerated return type of LikeCommentMutation."
type LikeCommentMutationPayload {
  "The comment that was liked."
  comment: Comment!
}

"Autogenerated return type of ListCollectionMutation."
type ListCollectionMutationPayload {
  "Returns true if collection was listed"
  success: Boolean!
}

"Autogenerated return type of LockCommentMutation."
type LockCommentMutationPayload {
  "The comment that was locked."
  comment: Comment!
}

"Autogenerated return type of LockThreadMutation."
type LockThreadMutationPayload {
  "The comment thread that was locked."
  commentThread: CommentThread!
}

"Facet fields specific to the media query."
input MediaFacet {
  "Facet on category."
  category: [String!]
  "Facet on media type."
  type: [String!]
  "Facet on game ID."
  gameId: [String!]
}

input MediaGeneralSearchFilterValue {
  "Value"
  value: String!
  "Comparison operator for value."
  op: FilterComparisonOperator
}

"Filter fields specific to the legacy media search query."
input MediaSearchFilter {
  "Nested filters."
  filter: [MediaSearchFilter!]
  "Logical operator for clauses."
  op: FilterLogicalOperator
  "Filter media by Game ID"
  gameId: [BaseFilterValue!]
  "Filter media by Game name"
  gameName: [BaseFilterValue!]
  "Date created, in unix timestamp"
  createdAt: [BaseFilterValue!]
  "Filter media by adult content"
  adultContent: [BooleanFilterValue!]
  "Type of media item (\"image\", \"supporter_image\" or \"video\")"
  type: [BaseFilterValue!]
  "Filter media by ID of the uploader"
  owner: [BaseFilterValue!]
  "Media status. Valid values are \"published\", \"under_moderation\" (moderators\/admins only),\n                  \"hidden\" (for images moderator\/admin only)"
  mediaStatus: [BaseFilterValue!]
  "Text search on title and description, partial match."
  generalSearch: [MediaGeneralSearchFilterValue!]
}

"Sort fields specific to the media query."
input MediaSearchSort {
  "Sort for 'new'."
  createdAt: BaseSortValue
  "Sort for 'trending'."
  rating: BaseSortValue
  "Sort for 'popular'."
  views: BaseSortValue
  "Sort for 'surprise'."
  random: RandomSortValue
}

"Available media statuses"
enum MediaStatus {
  "Publicly visible"
  published
  "Under moderation"
  under_moderation
  "Hidden"
  hidden
}

"Legacy Media Union"
union MediaUnion = Image | SupporterImage | Video

type MediaUnionPage {
  "Facets available, if supported for this query and requested."
  facets: [NodesFacet!]
  "Facets available, if supported for this query and requested. Schema is {\"facetName\":{\"facetValue\":count}}"
  facetsData: JSON
  "Nodes for pagination"
  nodes: [MediaUnion!]!
  "Number of nodes returned by this query"
  nodesCount: Int!
  "Facets available, if supported for this query and requested."
  nodesFacets: [NodesFacet!]
  "String representation of the filter query used to locate the nodes."
  nodesFilter: String
  "Total number of collections found."
  totalCount: Int!
}

"A mod"
type Mod {
  "If true, this mod contains adult content"
  adult: Boolean @deprecated(reason: "Deprecated in favour of `adult_content`.")
  "If true, this mod contains adult content"
  adultContent: Boolean
  "Author of this mod"
  author: String
  "Category name of this mod"
  category: String!
  "Time of when this mod was first created."
  createdAt: DateTime!
  "A detailed description of this mod"
  description: String!
  "Download count of this mod"
  downloads: Int!
  "Endorsement count of this mod"
  endorsements: Int!
  "Size of the primary mod file in kilobytes"
  fileSize: Int
  "Game changed by this mod"
  game: Game!
  "The database ID for this game."
  gameId: Int!
  "The database ID for this mod."
  id: ID!
  "If true, this mod is blocked from earning DP"
  isBlockedFromEarningDp: Boolean
  "Mirrors for this mod"
  mirrors: [ModMirror!]
  "A mod category"
  modCategory: ModCategory
  "The database ID for this mod."
  modId: Int!
  "Requirements of this mod"
  modRequirements: ModRequirements!
  "Name of this mod"
  name: String!
  "URL for the main mod image"
  pictureUrl: String
  "Status of this mod"
  status: String!
  "A brief summary of this mod"
  summary: String!
  "URL for the blurred thumbnail mod image"
  thumbnailBlurredUrl: String
  "URL for the large blurred thumbnail mod image"
  thumbnailLargeBlurredUrl: String
  "URL for the large thumbnail mod image"
  thumbnailLargeUrl: String
  "URL for the thumbnail mod image"
  thumbnailUrl: String
  "The database ID for this mod."
  uid: ID!
  "Time of when this mod was last updated."
  updatedAt: DateTime!
  "Uploader of this mod"
  uploader: User!
  "Version of this mod"
  version: String!
  "True if the viewer (current user) has blocked this mod"
  viewerBlocked: Boolean!
  "A timestamp indicating the last time the user downloaded this mod"
  viewerDownloaded: DateTime
  "True indicates endorsement, false for\n abstention. Will be null if the user has not endorsed the mod"
  viewerEndorsed: Boolean
  "True if the viewer (current user) is blocked from interacting with this mod"
  viewerIsBlocked: Boolean
  "If true, the viewer (current user) is tracking this mod."
  viewerTracked: Boolean!
  "True if the mod has been updated since the viewer (current user) downloaded it"
  viewerUpdateAvailable: Boolean
}

"The affiliation of user to a mod"
enum ModAffiliation {
  "The owner of the mod"
  OWNER
  "A contributor to the mod"
  CONTRIBUTOR
}

"The mod analytics for a specific month"
type ModAnalyticsByMonthNode {
  "Month"
  month: Int!
  "Total downloads"
  totalDownloads: BigInt!
  "Unique downloads"
  uniqueDownloads: BigInt!
  "Year"
  year: Int!
}

"A page of mod analytics grouped by month"
type ModAnalyticsByMonthPage {
  "A list of mod analytics by month nodes"
  nodes: [ModAnalyticsByMonthNode!]!
  "Information about the page"
  pageInfo: OffsetBasedPageInfo!
  "The total number of downloads for mods with which this user is affiliated"
  totalDownloads: BigInt!
  "The total number of unique downloads for mods with which this user is affiliated"
  totalUniqueDownloads: BigInt!
}

"Attributes to sort by for mod analytics by month"
enum ModAnalyticsByMonthSortBy {
  "Sort by date"
  DATE
  "Sort by total downloads"
  TOTAL_DOWNLOADS
  "Sort by total unique downloads"
  UNIQUE_DOWNLOADS
}

"The analytics for a mod within a month"
type ModAnalyticsForMonthNode {
  "Mod"
  mod: Mod!
  "Total downloads"
  totalDownloads: BigInt!
  "Unique downloads"
  uniqueDownloads: BigInt!
}

"A page of mod analytics grouped by month"
type ModAnalyticsForMonthPage {
  "A list of mod analytics for month nodes"
  nodes: [ModAnalyticsForMonthNode!]!
  "Information about the current page"
  pageInfo: OffsetBasedPageInfo!
  "The total number of downloads for the month"
  totalDownloads: BigInt!
  "The total number of unique downloads for the month"
  totalUniqueDownloads: BigInt!
}

"Attributes to sort by for mod analytics for month"
enum ModAnalyticsForMonthSortBy {
  "Sort by total downloads"
  TOTAL_DOWNLOADS
  "Sort by total unique downloads"
  UNIQUE_DOWNLOADS
}

"A mod category"
type ModCategory {
  "The database ID for this mod category."
  categoryId: Int!
  "Unix timestamp of category creation"
  date: Int
  "The database ID for this game."
  gameId: Int!
  "Comma separated mod category id and game id"
  id: ID!
  "Name of this category"
  name: String!
  "Comma separated list of legacy tag IDs"
  tags: String @deprecated(reason: "These tag identifiers are no longer used")
}

"A Mod Endorsement"
type ModEndorsement {
  "Id of endorsed entity"
  modUid: BigInt!
  "Endorsement status: abstained\/endorsed"
  status: String!
  "The database ID for this endorsement."
  userId: Int!
}

"The connection type for User."
type ModEndorserConnection {
  "A list of edges."
  edges: [ModEndorserEdge]
  "A list of nodes."
  nodes: [User]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Mod endorser edge"
type ModEndorserEdge {
  "A cursor for use in pagination."
  cursor: String!
  "Time of endorsement"
  endorsedAt: DateTime!
  "The item at the end of the edge."
  node: User
}

"Files belonging to a mod"
type ModFile implements Node {
  "The database ID for this File category."
  category: ModFileCategory!
  "The database ID for this File category."
  categoryId: Int!
  "Patch notes for this mod file version"
  changelogText: [String!]!
  "Number of downloads for this file"
  count: Int!
  "Unix Timestamp for when this file was uploaded"
  date: Int!
  "Description for this file"
  description: String
  "Forms a composite key with the game_id"
  fileId: Int!
  "Game that this file relates to"
  game: Game!
  "ID of the object."
  id: ID!
  "If true, this file can be downloaded by a mod manager"
  manager: Int!
  "Mod that this file belongs to"
  mod: Mod!
  "The database ID for this mod."
  modId: Int!
  "File name"
  name: String!
  "User that uploaded this file"
  owner: User!
  "If true, this file is the primary file for the mod"
  primary: Int!
  "URL for reporting this file"
  reportLink: String!
  "If true, popup will be displayed for showing the requirements"
  requirementsAlert: Int!
  "If true, this file has been virus scanned"
  scanned: Int!
  "Status of virus scanning on this file"
  scannedV2: VirusScanStatus!
  "Size of this file, in kilobytes"
  size: Int!
  "Size of this file, in bytes"
  sizeInBytes: BigInt
  "Number of downloads for this file"
  totalDownloads: Int!
  "Number of unique downloads for this file"
  uCount: Int!
  "Unique ID for this file"
  uid: ID!
  "Number of unique downloads for this file"
  uniqueDownloads: Int!
  "URL to download this file"
  uri: String!
  "Version this file relates to"
  version: String!
}

"Used to flag a mod file as a main, old or archived file."
enum ModFileCategory {
  MAIN
  UPDATE
  OPTIONAL
  OLD_VERSION
  MISCELLANEOUS
  REMOVED
  ARCHIVED
}

type ModFileContent {
  fileExtension: String!
  fileId: Int!
  fileName: String!
  filePath: String!
  filePathParts: [String!]!
  fileSize: BigInt!
  gameId: Int!
  "The database ID for this mod_file_content."
  id: String!
  modId: Int!
}

type ModFileContentPage {
  "Facets available, if supported for this query and requested."
  facets: [NodesFacet!]
  "Facets available, if supported for this query and requested. Schema is {\"facetName\":{\"facetValue\":count}}"
  facetsData: JSON
  "Nodes for pagination"
  nodes: [ModFileContent!]!
  "Number of nodes returned by this query"
  nodesCount: Int!
  "Facets available, if supported for this query and requested."
  nodesFacets: [NodesFacet!]
  "String representation of the filter query used to locate the nodes."
  nodesFilter: String
  "Total number of collections found."
  totalCount: Int!
}

input ModFileContentSearchFilter {
  "Nested filters."
  filter: [ModFileContentSearchFilter!]
  "Logical operator for clauses."
  op: FilterLogicalOperator
  fileId: [IntFilterValue!]
  modId: [IntFilterValue!]
  gameId: [IntFilterValue!]
  filePathWildcard: [BaseFilterValueEqualsWildcard!]
  filePathPartsExact: [BaseFilterValueEqualsMatches!]
  fileNameWildcard: [BaseFilterValueEqualsWildcard!]
  fileExtensionExact: [BaseFilterValueEqualsMatches!]
  fileSize: [BaseFilterValueNumeric!]
}

input ModFileContentSearchSort {
  gameId: BaseSortValue
  modId: BaseSortValue
  fileId: BaseSortValue
}

type ModFilePage {
  "Facets available, if supported for this query and requested."
  facets: [NodesFacet!]
  "Facets available, if supported for this query and requested. Schema is {\"facetName\":{\"facetValue\":count}}"
  facetsData: JSON
  "Nodes for pagination"
  nodes: [ModFile!]!
  "Number of nodes returned by this query"
  nodesCount: Int!
  "Facets available, if supported for this query and requested."
  nodesFacets: [NodesFacet!]
  "String representation of the filter query used to locate the nodes."
  nodesFilter: String
  "Total number of collections found."
  totalCount: Int!
}

"A download mirror for a mod"
type ModMirror {
  "Download count for this mirror"
  count: Int
  "The database ID for this game."
  gameId: Int!
  "The database ID for this mod mirror."
  id: ID!
  "The database ID for this mod."
  modId: Int!
  "Name of this mirror"
  name: String!
  "Download count for this mirror"
  totalDownloads: Int
  "URI for this mirror"
  uri: String
}

type ModPage {
  "Facets available, if supported for this query and requested."
  facets: [NodesFacet!]
  "Facets available, if supported for this query and requested. Schema is {\"facetName\":{\"facetValue\":count}}"
  facetsData: JSON
  "Nodes for pagination"
  nodes: [Mod!]!
  "Number of nodes returned by this query"
  nodesCount: Int!
  "Facets available, if supported for this query and requested."
  nodesFacets: [NodesFacet!]
  "String representation of the filter query used to locate the nodes."
  nodesFilter: String
  "Total number of collections found."
  totalCount: Int!
}

"Represents a mod requirement"
type ModRequirement {
  "If true, the requirement is external to the site. See the url field for the address."
  externalRequirement: Boolean!
  "The ID of the game that the required mod belongs to"
  gameId: ID!
  "The ID of the mod requirement"
  id: ID!
  "The ID of the mod that is required"
  modId: ID!
  "The name of the mod required"
  modName: String!
  "Notes about the mod requirement"
  notes: String
  "The URL of the mod that is required by the mod"
  url: String!
}

type ModRequirementPage {
  "Facets available, if supported for this query and requested."
  facets: [NodesFacet!]
  "Facets available, if supported for this query and requested. Schema is {\"facetName\":{\"facetValue\":count}}"
  facetsData: JSON
  "Nodes for pagination"
  nodes: [ModRequirement!]!
  "Number of nodes returned by this query"
  nodesCount: Int!
  "Facets available, if supported for this query and requested."
  nodesFacets: [NodesFacet!]
  "String representation of the filter query used to locate the nodes."
  nodesFilter: String
  "Total number of collections found."
  totalCount: Int!
}

"Represents the requirements of a mod"
type ModRequirements {
  "The DLC (expansion) requirements of the mod"
  dlcRequirements: [ModRequirementsDlc!]!
  "Other mods that require this mod"
  modsRequiringThisMod(offset: Int count: Int): ModRequiringPage!
  "Required mods for this mod"
  nexusRequirements(offset: Int count: Int): ModRequirementPage!
}

"Represents the DLC (expansion) requirements of a mod"
type ModRequirementsDlc {
  "The game expansion (DLC) required by the mod"
  gameExpansion: GameExpansion!
  "Notes about the expansion (DLC) requirement"
  notes: String
}

"Represents a mod requirement"
type ModRequiring {
  "If true, the requirement is external to the site. See the url field for the address."
  externalRequirement: Boolean!
  "The ID of the game that the mod belongs to"
  gameId: ID!
  "The ID of the mod requirement"
  id: ID!
  "The ID of the mod that is required"
  modId: ID!
  "The name of the mod that requires the mod"
  modName: String!
  "Notes about the mod requirement"
  notes: String
  "The URL of the mod that is required by the mod"
  url: String!
}

type ModRequiringPage {
  "Facets available, if supported for this query and requested."
  facets: [NodesFacet!]
  "Facets available, if supported for this query and requested. Schema is {\"facetName\":{\"facetValue\":count}}"
  facetsData: JSON
  "Nodes for pagination"
  nodes: [ModRequiring!]!
  "Number of nodes returned by this query"
  nodesCount: Int!
  "Facets available, if supported for this query and requested."
  nodesFacets: [NodesFacet!]
  "String representation of the filter query used to locate the nodes."
  nodesFilter: String
  "Total number of collections found."
  totalCount: Int!
}

"Used to define the source of a mod. Useful for informing Collections how to retrieve\nmods."
enum ModSource {
  "The Nexus website"
  nexus
  "A direct url to download from"
  direct
  "A general url to find the mod (further instructions may be provided)"
  browse
  "Manual instructions for installing the mod"
  manual
  "Mod files are included in the collection asset file, and do not need to be acquired separately"
  bundle
}

"An upload"
type ModUpload {
  "If true, this file has been claimed by a user"
  claimed: Boolean
  "If true, the content preview has been generated for this upload"
  contentPreviewGenerated: Boolean
  "Time of when this upload was first created."
  createdAt: String!
  "Time of when this upload was discarded."
  discardedAt: String
  "If true, this file has been reassembled from the uploaded chunks"
  fileChunksReassembled: Boolean
  "Forms a composite key with the game_id"
  fileId: Int
  "A Game"
  game: Game
  "The database ID for this upload."
  id: String!
  "The virus scanning status of this upload, provided by our internal virus scanning tools"
  internalVirusScanStatus: Int
  "The MD5 hash for this object in our object store"
  md5: String
  "Files belonging to a mod"
  modFile: ModFile
  "The database ID for this mod."
  modId: Int
  "If true, this file has been uploaded to object store"
  s3UploadComplete: Boolean
  "The URL for this object in our object store"
  s3Url: String
  "The HAS256 hash for this object in our object store"
  sha256: String
  "The size of this upload in bytes"
  sizeBytes: String
  "System filename for this upload"
  systemFileName: String
  "Temporary filename for this upload"
  tempFileName: String!
  "Time of when this upload was last updated."
  updatedAt: String!
  "Type of upload"
  uploadType: String
  "A Nexus Mods user"
  user: User
  "Number of positive reports from VirusTotal"
  virusTotalPositives: Int
  "The virus scanning status of this upload, provided by VirusTotal"
  virusTotalStatus: Int
  "The URL of the VirusTotal report for this upload"
  virusTotalUrl: String
}

"Moderatable Model Types"
enum Moderatable {
  "A nexusmods Collection of Mods"
  Collection
}

"Autogenerated return type of ModerateMutation."
type ModerateMutationPayload {
  "Return the moderation type"
  moderation: Moderation!
  "if true, this entity is put into moderation"
  success: Boolean!
}

"A moderation entry"
type Moderation {
  "Time of when this moderation was first created."
  createdAt: DateTime!
  "If true, this moderation entry can be edited"
  editable: Boolean!
  "The database ID for this moderation."
  id: ID!
  "Polymorphic ID of the entity that is being moderated"
  moderatableId: ID!
  "Polymorphic Type of the entity that is being moderated"
  moderatableType: Moderatable!
  "Array of fixes applied for this\nmoderation"
  moderationFixes: [ModerationFix!]
  "Reason for placing this entity\ninto moderation"
  moderationReason: ModerationReason!
  "The database ID for this staff member."
  staffId: ID!
  "Content for the staff note"
  staffNote: String
  "Date this entity was unlocked"
  unlockedAt: DateTime
  "User that unlocked this entity"
  unlockedBy: ID
  "Content for the message to show when unlocked"
  unlockedNote: String
  "Time of when this moderation was last updated."
  updatedAt: DateTime!
  "Staff member that put this entity into moderation"
  user: User!
  "Content for the user note"
  userNote: String
}

"A moderation fix submission"
type ModerationFix {
  "User who authored this moderation fix"
  author: User!
  "ID of the user who authored this moderation fix"
  authorId: ID!
  "Time of when this moderation fix was first created."
  createdAt: DateTime!
  "Description of this moderation fix"
  description: String
  "The database ID for this moderation fix."
  id: ID!
  "Type of moderation fix"
  moderation: Moderation!
  "Status of this moderation fix"
  status: ModerationFixStatus!
  "Time of when this moderation fix was last updated."
  updatedAt: DateTime!
}

"Available moderation fix statuses"
enum ModerationFixStatus {
  "Awaiting an Admin's approval"
  submitted
  "An Admin has accepted this fix"
  accepted
  "An Admin has rejected this fix"
  rejected
}

"A moderation reason"
type ModerationReason {
  "Time of when this moderation reason was first created."
  createdAt: DateTime!
  "The database ID for this moderation reason."
  id: ID!
  "Reason for moderation"
  reason: String!
  "Resolution of the moderation"
  resolution: String
  "Time of when this moderation reason was last updated."
  updatedAt: DateTime!
}

"A moderation restriction"
input ModerationRestrictionInput {
  "Reason"
  restriction: ModerationRestrictions!
  "Timeframe in days"
  timeframe: Int!
  "Mod ID"
  modId: ID
  "Game ID"
  gameId: ID
}

"Moderation restriction types"
enum ModerationRestrictions {
  FILE_UPLOAD
  MOD_TOOLS
  FILE_DOWNLOAD
  POST
  COMMENT_FILE
  IMAGE_UPLOAD
  ENDORSE_MOD
  ENDORSE_MEDIA
  BLOCK_PM
  ADD_VIDEOS
}

"A moderation_warning"
type ModerationWarning implements Node {
  "Category Id"
  category: ModerationWarningCategoryEnum!
  "Unix timestamp of moderation warning date"
  date: Int!
  "The database ID for this moderation warning."
  id: ID!
  "Has been read"
  isRead: Boolean!
  "Moderation warning link"
  link: String!
  "A moderation restriction"
  moderationWarningRestrictions("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): ModerationWarningRestrictionConnection
  "Forum post linked to warning"
  post: ForumPost
  "Post id of moderation warning"
  postId: ID
  "Public reason"
  publicReason: String
  "Reason for moderation warning"
  reason: String!
  "User id who removed moderation warning"
  removedBy: ID
  "Removed date of moderation warning"
  removedDate: Int
  "Removed reason"
  removedReason: String
  "Issuer of warning"
  staff: User!
  "User warning has been applied to"
  user: User!
}

"Moderation warning category types."
enum ModerationWarningCategoryEnum {
  INFORMAL_WARNING
  FORMAL_WARNING
  BAN
  UNBAN
  CLOSE_ACCOUNT
  AUTOMATIC_MESSAGE
  MANUAL_MESSAGE
}

"The connection type for ModerationWarning."
type ModerationWarningConnection {
  "A list of edges."
  edges: [ModerationWarningEdge]
  "A list of nodes."
  nodes: [ModerationWarning]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Total # of objects returned from this Plural Query"
  totalCount: Int!
}

"An edge in a connection."
type ModerationWarningEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ModerationWarning
}

"A moderation restriction"
type ModerationWarningRestriction implements Node {
  "Duration of restriction"
  duration: Int!
  "Restricted feature"
  featureId: ModerationWarningRestrictionFeatureEnum
  "The database ID for this moderation restriction."
  id: ID!
}

"The connection type for ModerationWarningRestriction."
type ModerationWarningRestrictionConnection {
  "A list of edges."
  edges: [ModerationWarningRestrictionEdge]
  "A list of nodes."
  nodes: [ModerationWarningRestriction]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Total # of objects returned from this Plural Query"
  totalCount: Int!
}

"An edge in a connection."
type ModerationWarningRestrictionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ModerationWarningRestriction
}

"Moderation warning restriction feature types."
enum ModerationWarningRestrictionFeatureEnum {
  FileUpload
  ModTools
  FileDownload
  Post
  CommentFile
  ImageUpload
  EndorseMod
  EndorseImage
  ChatBan
  BlockPM
  AddVideos
  EndorseVideos
}

"Autogenerated return type of ModifyImageForCollectionMutation."
type ModifyImageForCollectionMutationPayload {
  "Image that was updated on the collection"
  image: CollectionImage!
  "True when image was updated"
  updated: Boolean!
}

"Facet fields specific to the mods query."
input ModsFacet {
  "Facet on game domain name."
  gameDomainName: [String!]
  "Facet on game name."
  gameName: [String!]
  "Facet on game id."
  gameId: [String!]
  "Facet on adult."
  adult: [String!]
  "Facet on language."
  languageName: [String!]
  "Facet on status."
  status: [String!]
  "Facet on category."
  categoryName: [String!]
  "Facet on tag."
  tag: [String!]
}

"Filter fields specific to a Mods query"
input ModsFilter {
  "Nested filters."
  filter: [ModsFilter!]
  "Logical operator for clauses."
  op: FilterLogicalOperator
  "Mod name suitable for use with op:wildcard, but not op:matches. Punctuation matched."
  name: [BaseFilterValueEqualsWildcard!]
  "Stemmed name, suitable for token matching (op:wildcard and op:matches). Punctuation not matched."
  nameStemmed: [BaseFilterValue!]
  "Filter mods by Game ID"
  gameId: [BaseFilterValue!]
  "Filter mods by Game domain name"
  gameDomainName: [BaseFilterValue!]
  "Date created, in unix timestamp"
  createdAt: [BaseFilterValue!]
  "Date updated, in unix timestamp"
  updatedAt: [BaseFilterValue!]
  "Filter mods by whether they have been updated since they were created"
  hasUpdated: [BooleanFilterValue!]
  "Filter mods by uploader id"
  uploaderId: [BaseFilterValue!]
  "Filter mods by adult content"
  adultContent: [BooleanFilterValue!]
  "Filter mods by adult content"
  adult: [BooleanFilterValue!] @deprecated(reason: "Deprecated in favour of `adult_content`.")
  "Filter mods by file size"
  fileSize: [IntFilterValue!]
  "Filter mods by download count"
  downloads: [IntFilterValue!]
  "Filter mods by endorsement count"
  endorsements: [IntFilterValue!]
  "The tag name, exact match."
  tag: [BaseFilterValue!]
  "The description of the mod"
  description: [BaseFilterValueEqualsMatches!]
  "The name of the author"
  author: [BaseFilterValue!]
  "The name of the uploader"
  uploader: [BaseFilterValue!]
  "Filter mods by whether they support Vortex"
  supportsVortex: [BooleanFilterValue!]
  "The language of the mod"
  languageName: [BaseFilterValue!]
  "The mod category"
  categoryName: [BaseFilterValue!]
  "The mod status"
  status: [BaseFilterValue!]
  "The name of the game this mod is for"
  gameName: [BaseFilterValue!]
  "Filter mods by image, as returned by pictureUrl and thumbnailUrl."
  primaryImage: [BaseFilterValue!]
}

"Sort fields specific to a Mods query."
input ModsSort {
  "Filter query relevance, works best with non wildcard queries."
  relevance: BaseSortValue
  "Mod name."
  name: BaseSortValue
  "Number of times downloaded."
  downloads: BaseSortValue
  "Number of unique downloads."
  uniqueDownloads: BaseSortValue
  "Number of times endorsed."
  endorsements: BaseSortValue
  "Random mods."
  random: RandomSortValue
  "Date created."
  createdAt: BaseSortValue
  "Date updated."
  updatedAt: BaseSortValue
  "Mod file size."
  size: BaseSortValue
  "Date of last comment."
  lastComment: BaseSortValue
}

"All mutations to update, create and delete data"
type Mutation {
  "Abstains from mod endorsement."
  abstainFromModEndorsement("ID of the mod the endorsement is for." modUid: String!): AbstainFromModEndorsementMutationPayload
  "Marks the fix as accepted and takes the collection out of moderation.\nOnly collection moderators can call this mutation"
  acceptModerationFix("The database ID for this moderation fix." moderationFixId: ID!): AcceptModerationFixMutationPayload
  "Adds a badge to a collection."
  addBadgeToCollection("ID of badge to apply to the collection" badgeId: ID! "ID of collection to have badge applied to" collectionId: Int!): AddBadgeToCollectionMutationPayload
  "Adds a game to a user's favourites"
  addFavouriteGame("The game to add" gameId: ID!): AddFavouriteGameMutationPayload
  "Adds a new header image to a collection"
  addHeaderImageToCollection("Image to be added" image: UploadImageInput! "ID of collection to add image to" collectionId: ID!): AddHeaderImageToCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Adds a new image to a collection"
  addImageToCollection("Image to be added" image: UploadImageInput! "ID of collection to add image to" collectionId: ID! "ID of collection revision to add image to" collectionRevisionId: ID): AddImageToCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Adds a tag to a collection. User must have the `collection:add_tag` permission"
  addTagToCollection("IDs of tags to add to the collection" tagIds: [ID!]! "ID of collection to add tags to" collectionId: Int!): AddTagToCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Adds a new tile image to a collection"
  addTileImageToCollection("Image to be added" image: UploadImageInput! "ID of collection to add image to" collectionId: ID!): AddTileImageToCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Adds a new image to a collection"
  addVideoToCollection("Video to be added" video: UploadVideoInput! "ID of collection to add video to" collectionId: ID! "ID of collection revision to add video to" collectionRevisionId: ID): AddVideoToCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Updates existing Moderation entity. Used to update details about the moderation or to unlock it."
  amendModeration("ID of the Moderation entity" id: ID! "Note displayed to the end user." userNote: String "Note displayed to internally to staff members." staffNote: String "Enable or disable editing of the entity." editable: Boolean "When TRUE, the entity will no longer be moderated." unlocked: Boolean "Note for the end user when moderation is\nunlocked" unlockedNote: String "Change collection\nstatus upon amending the moderation." collectionStatus: CollectionStatus "Change moderation reason." moderationReasonId: ID): AmendModerationMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Ignores a specific user for the current user."
  blockAuthor("The username of the user to block (this or user_id must be set)" userName: String "The ID of the user to block (this or user_name must be set)." userId: ID "This is an alias for userName." authorName: String "This is an alias for userId." authorId: ID): BlockUserMutationPayload @deprecated(reason: "This mutation will be replaced with ignore_user mutation")
  "Allows the current user to block all of a user's existing mods from earning DP."
  blockModsFromEarningDp("The ID of the user for whom to block mods." userId: ID): BlockModsFromEarningDpMutationPayload
  "Blocks a specific tag for the current user."
  blockTag("The database ID for this tag." tagId: ID!): BlockTagMutationPayload
  "Changes a collection owner."
  changeCollectionOwner("Collection ID" collectionId: ID! "New owner ID" ownerId: ID!): ChangeCollectionOwnerPayload
  "Clears the status of an existing bug report on a collection"
  clearCollectionBugReportModerationStatus("ID of the collection bug report to clear status of" bugReportId: ID!): ClearCollectionBugReportModerationStatusMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Clears the moderation status of a comment."
  clearCommentModerationStatus("The database ID for this comment." commentId: ID!): ClearCommentModerationStatusMutationPayload
  "Clears the moderation status of a comment thread."
  clearCommentThreadModerationStatus("The database ID for this comment thread." commentThreadId: ID!): ClearThreadModerationStatusMutationPayload
  "Marks a collection bug report as closed. Can be called by the reporter or the collection curator, but only the curator can specify a closure_reason"
  closeCollectionBugReport("ID of the collection bug report to close" bugReportId: ID! "The status of the bug report, e.g. Resolved, Won't fix" closureReason: BugReportClosureReason!): CloseCollectionBugReportMutationPayload
  "Creates an API Key for a user"
  createApiKey("The application to create the key for. Pass null to create a personal API key." applicationId: ID): CreateApiKeyMutationPayload
  "Creates a revision changelog entry"
  createChangelog("Revision ID" revisionId: ID! "Changelog description" description: String!): CreateChangelogMutationPayload
  "Create a new Collection. Must be passed the collection data from the manifest containing\n  the manifest schema."
  createCollection("Collection payload required for the collection creation." collectionData: CollectionPayload! "UUID of the temporary collection file. Once the creation process is completed,\n  the file will be moved to a permanent storage space." uuid: String!): CreateCollectionMutationPayload
  "Creates a new bug report for a collection"
  createCollectionBugReport("ID of collection to add bug report to" collectionId: ID! "Number of collection revision to add bug report to" collectionRevisionNumber: Int! "Title of the new bug report" title: String! "Description for the new bug report" description: String "Array of attachment ids of uploaded files" attachmentIds: [ID!]): CreateCollectionBugReportMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Creates a comment."
  createComment("The database ID for this comment thread." commentThreadId: ID! "The comment body." body: String! "An optional comment ID to reply to." replyToId: ID "An optional array of attachment_ids from uploaded files to attach." attachmentIds: [ID!]): CreateCommentMutationPayload
  "Create a new CSAM Deletion Request"
  createCsamDeletionRequest("List of CSAM URLs to be deleted" csamUrls: String!): CreateCsamDeletionRequestPayload
  "Create a new message"
  createMessage("User IDs of recipients" to: [Int!]! "Title of message" title: String! "Body of message" body: String!): CreateMessagePayload
  "Creates an endorsement for a mod."
  createModEndorsement("ID of the mod the endorsement is for." modUid: String!): CreateModEndorsementMutationPayload
  "Creates a moderation note about a user"
  createNoteAboutUser("The database ID for this user." userId: ID! "The moderation note" note: String!): CreateNoteAboutUserMutationPayload
  "Creates a new Collection Revision, or updates an existing Collection Revision (if a\n  draft already exists )"
  createOrUpdateRevision("The data payload used to create a collection revision" collectionData: CollectionPayload! "The database ID for this collection." collectionId: Int! "TODO" uuid: String!): CreateOrUpdateRevisionMutationPayload
  "Creates a new collection Tag"
  createTag("Tag name" name: String! "Tag category ID" categoryId: ID "Array containing Game IDs to\nbe associated with the tag" gameIds: [ID!] "Is the tag global\n(not game specific)" global: Boolean "Is this an adult content tag" adult: Boolean): CreateTagMutationPayload
  "Deletes a user's API Key"
  deleteApiKey("The application to delete the key for." applicationId: ID!): DeleteApiKeyMutationPayload
  "Deletes a user's personal API Key"
  deletePersonalApiKey: DeletePersonalApiKeyMutationPayload
  "Discards an entire Collection and its associated entities"
  discardCollection("Collection ID" collectionId: ID! "Discard reason" reason: String!): DiscardCollectionMutationPayload
  "Discards a comment."
  discardComment("The database ID for this comment." commentId: ID!): DiscardCommentMutationPayload
  "Discards a Collection Revision. Revision can only be discarded if it is a DRAFT or is not older than\n24 hours and has no more than a 100 unique downloads."
  discardRevision("Collection ID" collectionId: ID! "Revision number" revisionNumber: Int! "Discard Reason" reason: String): DiscardRevisionMutationPayload
  "Removed an existing tag. User must have the `tag:discard` permission"
  discardTag("The database ID for this category." id: ID!): DiscardTagMutationPayload
  "Updates the core details for a collection such as the name, description and category"
  editCollection("The database ID for this collection." collectionId: Int! "Name of this collection" name: String "Collection summary" summary: String "Description of this collection" description: String "ID of the parent category" categoryId: ID "If true, allow user-uploaded content" allowUserMedia: Boolean "If true, media needs to be verified" manuallyVerifyMedia: Boolean): EditCollectionMutationPayload
  "Creates an endorsement for a generic Endorsable model. TODO: This will be moving to a\nmodel-specific mutation"
  endorse("Used to determine whether the endorsement entry is used for abstaining.\nUsers that abstain from endorsing a file will not get send future endorsement reminders." abstain: Boolean "ID of an entity the endorsement is for." modelId: Int! "Type of an entity the endorsement is for." modelType: String!): CreateEndorsementMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Allows the current user to give kudos to another user"
  giveKudos("The ID of the user to give kudos to." kudosUserId: ID): GiveKudosMutationPayload
  "Hides a bug report on a collection from public view"
  hideCollectionBugReport("ID of the collection bug report to hide" bugReportId: ID! "Public reason to hide the bug report" reason: String "Company internal reason to hide the bug report" internalReason: String): HideCollectionBugReportMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Hides a comment."
  hideComment("The database ID for this comment." commentId: ID! "The reason for hiding the comment." reason: String! "The internal reason for hiding the comment. Only visible to admins and moderators." internalReason: String): HideCommentMutationPayload
  "Ignores a specific user for the current user."
  ignoreUser("The username of the user to block (this or user_id must be set)" userName: String "The ID of the user to block (this or user_name must be set)." userId: ID): IgnoreUserMutationPayload
  "Issues a moderation warning to a user"
  issueWarningToUser("The database ID for this user." userId: ID! "Whether the warning is informal or formal" warning: FormalOrInformalWarning! "The reason for the warning" reason: String! "The public reason for the warning" publicReason: String "Reference links for the warning" referenceLinks: [String!] "The database ID for this comment." commentId: ID "Restrictions to apply to the user" restrictions: [ModerationRestrictionInput!]): IssueWarningToUserMutationPayload
  "Likes a comment."
  likeComment("The database ID for this comment." commentId: ID!): LikeCommentMutationPayload
  "Sets a collection as `listed`. A collection can only be listed if there are published revisions.\nUser must have the `collection:set_status` permission"
  listCollection("The database ID for this collection." collectionId: Int!): ListCollectionMutationPayload
  "Locks a comment."
  lockComment("The database ID for this comment." commentId: ID!): LockCommentMutationPayload
  "Locks a comment thread."
  lockCommentThread("The database ID for this comment thread." commentThreadId: ID!): LockThreadMutationPayload
  "Sets a collection as `under_moderation`, allowing the user to provide a reason and the\nability to 'lock' the collection against future editing. User must have the `collection:moderate` permission."
  moderate("Moderatable ID - ID of the object intended to be moderated" id: ID! "Moderatable type" type: Moderatable! "Moderation note visible to the user" userNote: String "Moderation note only visible to staff" staffNote: String "If true, this entity cannot be edited by the author" editable: Boolean "The database ID for this moderation reason." moderationReasonId: ID!): ModerateMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Updates an image on a collection"
  modifyImageForCollection("Image to be updated" image: UpdateImageInput! "ID of collection to update image on" collectionId: ID!): ModifyImageForCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Re-opens a previously closed bug report. Can be called by the report or the collection curator"
  openCollectionBugReport("ID of the collection bug report to open" bugReportId: ID!): OpenCollectionBugReportMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Pins a comment. User must have the `comment:pin?` permission"
  pinComment("The database ID for this comment." commentId: ID!): PinCommentMutationPayload
  "Publishes a Collection Revision"
  publishRevision("Collection Revision ID" revisionId: ID! "Allows a curator to\nset the collection status when this revision is published" collectionStatus: CollectionStatus "Does this revision contain adult content\nresources" hasAdultResources: Boolean): PublishRevisionMutationPayload
  "Votes for a generic Rateable model. TODO: This will be moved to model-specific mutations"
  rate("ID of the entity the rating is for" id: ID! "Type of the entity the rating is for" type: Ratable! "Rating value" rating: RatingOptions!): CreateRatingMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Marks the moderation fix as rejected. The collection status is not changed.\nOnly collection moderators can call this mutation"
  rejectModerationFix("The database ID for this moderation fix." moderationFixId: ID!): RejectModerationFixMutationPayload
  "Removes a badge from a collection."
  removeBadgeFromCollection("ID of badge to remove from the collection" badgeId: ID! "ID of collection to have badge removed from" collectionId: Int!): RemoveBadgeFromCollectionMutationPayload
  "Removes the current user's like from a comment."
  removeCommentLike("The database ID for this comment." commentId: ID!): RemoveCommentLikeMutationPayload
  "Removes a game from a user's favourites"
  removeFavouriteGame("The game to remove" gameId: ID!): RemoveFavouriteGameMutationPayload
  "Removes a header image from a Collection"
  removeHeaderImageFromCollection("The database ID for this collection." collectionId: ID!): RemoveHeaderImageFromCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Removes an image from a Collection"
  removeImageFromCollection("The database ID for this image." imageId: ID! "The database ID for this collection." collectionId: ID!): RemoveImageFromCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Allows the current user to remove kudos from another user"
  removeKudos("The ID of the user to remove kudos from." kudosUserId: ID): RemoveKudosMutationPayload
  "Removes tags from a collection"
  removeTagFromCollection("Array containing Tag IDs" tagIds: [ID!]! "Collection ID" collectionId: ID!): RemoveTagFromCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Removes a tile image from a Collection"
  removeTileImageFromCollection("The database ID for this collection." collectionId: ID!): RemoveTileImageFromCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Removes a video from a Collection"
  removeVideoFromCollection("The database ID for this video." videoId: ID! "The database ID for this collection." collectionId: ID!): RemoveVideoFromCollectionMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Moves an item to a new position in a list."
  reorderItem("The global ID of the item to move." id: ID! "The global ID of the item to move towards." targetId: ID! "The new location of the item, in relation to the target item." location: ReorderLocation!): ReorderItemPayload
  "Reorders pinned comments. User must have the `comment:pin?` permission"
  reorderPinnedComments("The database ID for this comment." commentIds: [ID!]!): ReorderPinnedCommentsMutationPayload
  "Restores a discarded comment."
  restoreComment("The database ID for this comment." commentId: ID!): RestoreCommentMutationPayload
  "Retracts a Collection Revision. This keeps the revision listed and downloadable but marks it as\na revision that should not be used anymore."
  retractRevision("Collection Revision ID" revisionId: ID! "Retraction Reason" reason: String!): RetractRevisionMutationPayload
  "Submits a moderation fix against a moderation that is pending acceptance"
  submitModerationFix("The database ID for this moderation fix." moderationId: ID! "Additional information from the curation for\nthis fix" description: String): SubmitModerationFixMutationPayload
  "Track desktop application events and metrics"
  trackAppMetric("Type of event being tracked" eventType: AppMetricEventType! "Type of entity associated with the event, e.g., \"collection\"" entityType: AppMetricEntityType! "Unique identifier for the entity, e.g., collection ID" entityId: String! "Client identifier" clientString: String "Additional metadata as JSON object" metadata: JSON): TrackAppMetricMutationPayload
  "Allows the current user to track a mod"
  trackMod("The ID of the mod to be tracked." modUid: ID!): TrackModMutationPayload
  "Allows the current user to track another user"
  trackUser("The ID of the user to be tracked." trackedUserId: ID): TrackUserMutationPayload
  "Unignore a specific author for the current user."
  unblockAuthor("The username of the user to unignore (this or user_id must be set)." userName: String "The ID of the author to unignore (this or user_name must be set)." userId: ID "This is an alias for userName." authorName: String "This is an alias for userId." authorId: ID): UnblockUserMutationPayload
  "Allows the current user to unblock all of a user's existing mods from earning DP."
  unblockModsFromEarningDp("The ID of the user for whom to unblock mods." userId: ID): UnblockModsFromEarningDpMutationPayload
  "Unblocks a specific tag for the current user."
  unblockTag("The database ID for this tag." tagId: ID!): UnblockTagMutationPayload
  "Unignore a specific author for the current user."
  unignoreUser("The username of the user to unignore (this or user_id must be set)." userName: String "The ID of the author to unignore (this or user_name must be set)." userId: ID): UnignoreUserMutationPayload
  "Unlists a Collection Revision from the public Nexus Mods pages."
  unlistCollection("Collection ID" collectionId: ID!): UnlistCollectionMutationPayload
  "Unpins a comment. User must have the `comment:unpin?` permission"
  unpinComment("The database ID for this comment." commentId: ID!): UnpinCommentMutationPayload
  "Retracts a Collection Revision. This keeps the revision listed and downloadable but marks it as\na revision that should not be used anymore."
  unpublishRevision("Collection Revision ID" revisionId: ID! "Retraction Reason" reason: String!): RetractRevisionMutationPayload @deprecated(reason: "Legacy Field - this will be removed in a future update.")
  "Allows the current user to untrack a mod"
  untrackMod("The ID of the mod to be un-tracked." modUid: ID!): UntrackModMutationPayload
  "Makes the current user stop tracking another user"
  untrackUser("The ID of the user to stop tracking." trackedUserId: ID): UntrackUserMutationPayload
  "Updates a user's bio (About Me) on their profile"
  updateAboutMe("The user whose bio we are updating (or current user if nil)." userId: ID "The new text for the about me section in bio." about: String!): UpdateAboutMeMutationPayload
  "Updates existing revision changelog"
  updateChangelog("Changelog ID" changelogId: ID! "Changelog description" description: String!): UpdateChangelogMutationPayload
  "Updates a bug report on a collection"
  updateCollectionBugReport("ID of the collection bug report to update" bugReportId: ID! "Number of collection revision to update bug report on" collectionRevisionNumber: Int "Title of the new bug report" title: String! "Description of the new bug report" description: String "Array of attachment ids" attachmentIds: [ID!]): UpdateCollectionBugReportMutationPayload @deprecated(reason: "This mutation will be replaced using Interfaces and Global IDs")
  "Updates a comment."
  updateComment("The database ID for this comment." commentId: ID! "The comment body." body: String! "An array of attachment_ids of uploaded files to attach to the new revision.Include all the previous ids or they won't be present on the updated revision.If you don't send an array the previous revisions attachments will be maintained" attachmentIds: [ID!]): UpdateCommentMutationPayload
  "Updates a user's country on their profile"
  updateCountry("The user whose country to update (current user if omitted)." userId: ID "ISO Country Code (can also be null)" country: String): UpdateCountryMutationPayload
  "Update the detailed status of a CSAM Deletion Request"
  updateCsamDeletionRequest("ID of the CSAM Deletion Request to update" id: Int! "Detailed status information for the CSAM Deletion Request" detailedStatus: CsamDeletionRequestCDNResult! "Secret key for CDNs to authenticate" cdnSecret: String): UpdateCsamDeletionRequestPayload
  "Updates a game"
  updateGame("ID of the game to update" gameId: Int! "New artwork schema to use" artworkSchema: GameArtworkSchema "Set to true if the game name is a copyrighted asset" copyrightedName: Boolean): UpdateGameMutationPayload
  "Updates a users moderation warning"
  updateModerationWarning("The database ID for this moderation warning." moderationWarningId: ID! "Whether the moderation warning has been read \/ acknowledged" isRead: Boolean!): LegacyUpdateModerationWarningMutationPayload
  "Updates a users preferences"
  updatePreferences("Default mods tab" defaultModsTab: PreferencesDefaultModsTabEnum "Default mods tab time range" defaultModsTabTimeRange: PreferencesTimeRangeEnum "Default media tab" defaultMediaTab: PreferencesDefaultMediaTabEnum "Default media tab time range" defaultMediaTabTimeRange: PreferencesTimeRangeEnum "Comments about a users files, images and videos" subfeedsCommentsYour: Boolean "Activity about a users files, images and videos" subfeedsActivityYour: Boolean "Comments about tracked files, images and videos" subfeedsCommentsTracked: Boolean "Activity about tracked files, images and videos" subfeedsActivityTracked: Boolean "Author tracked files, images and videos" subfeedsAuthorTracked: Boolean "Default sorting option" defaultOrder: PreferencesDefaultSortEnum "Default search view" defaultSearchView: PreferencesDefaultSearchViewEnum "Number of items to show per page" results: PreferencesResultsEnum "Number of comments to show per page" comments: PreferencesCommentsEnum "Preferred download location" dlLocation: PreferencesDlLocationEnum "User reminder for file ratings" reminder: PreferencesReminderEnum "Images added by author in image description" imageShowcase: PreferencesImageShowcaseEnum "Replies to posts bump original post" bubbleReply: Boolean "Display user activity" disableProfileActivity: Boolean "Display when user was last active" displayLastActivity: Boolean "Show adult content" adult: Boolean "Blur adult images" adultBlurImages: Boolean "Preferred download method" download: PreferencesDownloadMethodEnum "Display notifications" notificationsActive: Boolean "Display game specific notifications when on game pages" notificationsGameSpecific: Boolean "Default search type" defaultSearchType: PreferencesSearchTypeEnum "Receive marketing emails" marketingEmails: Boolean): LegacyUpdatePreferencesMutationPayload
  "Updates a specific Collection Revision with new installation information and adult\ncontent flags"
  updateRevision("ID of the collection revision to update" revisionId: Int! "User-provided installation information" installationInfo: String "Whether this revision has adult content" adultContent: Boolean): UpdateRevisionMutationPayload
  "Updates a collection Tag"
  updateTag("Collection Tag ID" id: ID! "Tag name" name: String "Tag category ID" categoryId: ID "Games IDs to be associated with the Tag" gameIds: [ID!] "Is the tag global (non game specific)" global: Boolean "Is this an adult content Tag" adult: Boolean): UpdateTagMutationPayload
  "Updates a user's donation preferences."
  updateUserDonationPreferences("Whether the user has enabled straight donations." donateStraight: Boolean "Whether the user has enabled author premium donations." donateAuthorpremium: Boolean "Whether the user has enabled own premium donations." donateOwnpremium: Boolean "Whether the user has enabled profile donations." donateProfile: Boolean "The maximum amount of premium time in months a user can donate." donatePremiumMax: Int "Whether the user has opted in to the Donation Points program." dpOptedIn: Boolean "The user's PayPal email address." paypal: String): UpdateUserDonationPreferencesPayload
  "Uploads a file to later be attached to an Attachable entity"
  uploadAttachment("A file to upload that will be later attached to an entity" file: Upload!): UploadAttachmentMutationPayload
  "TODO"
  uploadGameArtworkV2("ID of the game to update." gameId: Int! "TODO" tileFile: Upload "TODO" heroFile: Upload "TODO" thumbnailFile: Upload): UploadGameArtworkV2MutationPayload
  "Writes a full page notification to a user"
  writeFullPageNotificationToUser("The database ID for this user." userId: ID! "The full page notification title" title: String! "The full page notification message" message: String! "The full page notification reference links" referenceLinks: [String!]): WriteFullPageNotificationToUserMutationPayload
}

"A News article, stored and originally defined by the legacy forum"
type News {
  "Author of this News Article"
  author: User!
  "The number of comments on this article"
  commentsCount: Int!
  "Content of this news article"
  content: String!
  "Date this news article was created"
  date: ISO8601DateTime!
  "Games this news article is related to"
  games: [Game!]!
  "The name of the image on the forum"
  header: String
  "Is this news article written in HTML?"
  html: Boolean!
  "The database ID for this news."
  id: ID!
  "The name of the image on the forum"
  image: String
  "Category of this news article"
  newsCategory: NewsCategory!
  "If the news article has a source, this is it's name"
  sourceName: String
  "If the news article has a source, this is the URL"
  sourceUrl: String
  "Summary of this news article"
  summary: String!
  "Title of this news article"
  title: String!
  "The name of the uncropped image on the forum"
  uncroppedHeader: String
  "The name of the uncropped image on the forum"
  uncroppedImage: String
}

"A news category"
type NewsCategory {
  "The database ID for this news category."
  id: ID!
  "Name of this category"
  name: String!
}

"Forum news articles type."
enum NewsCategoryEnum {
  SITE_NEWS
  GAME_NEWS
  MOD_NEWS
  INTERVIEWS
  COMPETITIONS
  FEATURES
}

type NewsPage {
  "Facets available, if supported for this query and requested."
  facets: [NodesFacet!]
  "Facets available, if supported for this query and requested. Schema is {\"facetName\":{\"facetValue\":count}}"
  facetsData: JSON
  "Nodes for pagination"
  nodes: [News!]!
  "Number of nodes returned by this query"
  nodesCount: Int!
  "Facets available, if supported for this query and requested."
  nodesFacets: [NodesFacet!]
  "String representation of the filter query used to locate the nodes."
  nodesFilter: String
  "Total number of collections found."
  totalCount: Int!
}

"An object with an ID."
interface Node {
  "ID of the object."
  id: ID!
}

"Metadata about a single facet value."
type NodesFacet {
  "Number of results available for this facet value. Affected by values set on other facets."
  count: Int!
  "Name matching the graphql facet request."
  facet: String!
  "Value available for this facet. May be used in a subsequent facet request to filter the results by facet."
  value: String!
}

"Information about a page of items"
type OffsetBasedPageInfo {
  "Whether there is a next page"
  hasNextPage: Boolean!
  "Whether there is a previous page"
  hasPreviousPage: Boolean!
  "The current page number"
  page: Int!
  "The number of items per page"
  pageSize: Int!
  "The total number of items"
  totalCount: Int!
}

"Autogenerated return type of OpenCollectionBugReportMutation."
type OpenCollectionBugReportMutationPayload {
  "Collection bug report which was re-opened"
  collectionBugReport: CollectionBugReport!
}

"Represents a single opted in mod"
type OptedInMod {
  "Time of when this OptedInMod was first created."
  createdAt: DateTime!
  "Game"
  game: Game
  "The ID of the game the mod belongs to"
  gameId: Int!
  "The database ID for this opted in mod."
  id: Int!
  "Mod"
  mod: Mod
  "ID of the that was opted in"
  modId: Int!
  "Ratio of the DP from this mod shared with this user"
  ratio: Float!
  "Uploader of the mod"
  uploader: User
  "ID of the uploader of the mod. This\nmight not be the current user, as mod authors can share mod DP with other users."
  uploaderId: Int!
}

"A list of mods that this user has been opted into"
type OptedInMods {
  "Number of mods this user has opted in"
  count: Int!
  "Mods that have been opted in"
  entries: [OptedInMod!]!
  "User"
  user: User!
  "ID of the user"
  userId: Int!
}

"Information about pagination in a connection."
type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: String
  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
}

"An entity to represent either an account or a bank"
type PaymentEntity {
  "The database ID for this payment entity."
  id: Int!
  "Name of this entity"
  label: String!
  "Type of entity"
  type: String!
}

"A global or entity-specific permission granted to a user"
type Permission {
  "If true, this permission is being granted globally from the user's role"
  global: Boolean!
  "Permission string being granted E.g. 'collection:publish'"
  key: String!
}

"Autogenerated return type of PinCommentMutation."
type PinCommentMutationPayload {
  "The comment that was pinned."
  comment: Comment!
}

"A user preference"
type Preference implements Node {
  "Show adult content"
  adult: Boolean!
  "Blur adult images"
  adultBlurImages: Boolean!
  "Replies to posts bump original post"
  bubbleReply: Boolean!
  "Amount of comments per page."
  comments: PreferencesCommentsEnum!
  "Default media tab."
  defaultMediaTab: PreferencesDefaultMediaTabEnum!
  "Time range values for preferences."
  defaultMediaTabTimeRange: PreferencesTimeRangeEnum!
  "Default mods tab."
  defaultModsTab: PreferencesDefaultModsTabEnum!
  "Time range values for preferences."
  defaultModsTabTimeRange: PreferencesTimeRangeEnum!
  "Default sorting option."
  defaultOrder: PreferencesDefaultSortEnum!
  "Default search types"
  defaultSearchType: PreferencesSearchTypeEnum!
  "Default search view."
  defaultSearchView: PreferencesDefaultSearchViewEnum!
  "Display user activity"
  disableProfileActivity: Boolean!
  "Display when user was last active"
  displayLastActivity: Boolean!
  "Download location."
  dlLocation: PreferencesDlLocationEnum!
  "Preferred download method"
  download: PreferencesDownloadMethodEnum!
  "ID of the object."
  id: ID!
  "Image showcase."
  imageShowcase: PreferencesImageShowcaseEnum!
  "If true, this user is blocking content"
  isBlockingContent: Boolean!
  "Whether the user has opted in to marketing emails"
  marketingEmails: Boolean!
  "Display notifications"
  notificationsActive: Boolean!
  "Game specific notifications when visiting game pages"
  notificationsGameSpecific: Boolean!
  "Endorsement reminder."
  reminder: PreferencesReminderEnum!
  "Amount of results per page."
  results: PreferencesResultsEnum!
  "Activity about tracked files, images and videos"
  subfeedsActivityTracked: Boolean!
  "Activity about a users files, images and videos"
  subfeedsActivityYour: Boolean!
  "Author tracked files, images and videos"
  subfeedsAuthorTracked: Boolean!
  "Comments about tracked files, images and videos"
  subfeedsCommentsTracked: Boolean!
  "Comments about a users files, images and videos"
  subfeedsCommentsYour: Boolean!
}

"Amount of comments per page."
enum PreferencesCommentsEnum {
  COMMENTS_10
  COMMENTS_20
  COMMENTS_30
  COMMENTS_40
  COMMENTS_50
}

"Default media tab."
enum PreferencesDefaultMediaTabEnum {
  NEW
  TRENDING
  POPULAR
  RANDOM
}

"Default mods tab."
enum PreferencesDefaultModsTabEnum {
  NEW
  TRENDING
  POPULAR
  RANDOM
  UPDATED
}

"Default search view."
enum PreferencesDefaultSearchViewEnum {
  STANDARD
  LIST
  COMPACT
}

"Default sorting option."
enum PreferencesDefaultSortEnum {
  BY_RECENT_FILES
  BY_ENDORSEMENTS
  BY_DOWNLOADS
  BY_UNIQUE_DOWNLOADS
  BY_LAST_UPDATED_FILE
  BY_AUTHOR_NAME
  BY_FILE_NAME
  BY_FILE_SIZE
  RANDOM_SORTING
  LAST_COMMENT
}

"Download location."
enum PreferencesDlLocationEnum {
  NEXUS_CDN
  AMSTERDAM
  PRAGUE
  CHICAGO
  LOS_ANGELES
  MIAMI
}

"Download method."
enum PreferencesDownloadMethodEnum {
  POP_UP_BOX
  SEPARATE_PAGE
}

"Image showcase."
enum PreferencesImageShowcaseEnum {
  NOT_SET
  CHOOSE_ON_PER_IMAGE_BASIS
  TURN_OFF_IMAGES
  TURN_ON_IMAGES
}

"Endorsement reminder."
enum PreferencesReminderEnum {
  NEVER
  DAYS_1
  DAYS_3
  DAYS_7
  DAYS_14
  DAYS_28
}

"Amount of results per page."
enum PreferencesResultsEnum {
  RESULTS_20
  RESULTS_40
  RESULTS_60
  RESULTS_80
}

"Search types."
enum PreferencesSearchTypeEnum {
  ALL_CONTENT
  GAMES
  MODS
  COLLECTIONS
  IMAGES
  VIDEOS
  USERS
}

"Time range values for preferences."
enum PreferencesTimeRangeEnum {
  ALL_TIME
  ONE_DAY
  ONE_WEEK
  TWO_WEEKS
  FOUR_WEEKS
  ONE_YEAR
}

"returned attributes for presigned post requests"
type PresignedUrl {
  "Presigned URL"
  url: String!
  "UUID"
  uuid: String!
}

"A public changelog attached to a collection revision.\n      If you need to access more fields, use CollectionChangelogType instead."
type PublicCollectionChangelog {
  "The id of the collection revision for which this changelog was created"
  collectionRevisionId: Int!
  "Time of when this collection changelog was first created."
  createdAt: DateTime!
  "The content of the collection changelog, in Markdown format"
  description: String!
  "The database ID for this collection changelog."
  id: Int!
  "The revision number of the collection revision for which this changelog was created"
  revisionNumber: Int!
  "Time of when this collection changelog was last updated."
  updatedAt: DateTime!
}

"A public collection revision type.\n      If you need to access more fields, use CollectionRevisionType instead."
type PublicCollectionRevision {
  "A changelog attached to a collection revision"
  collectionChangelog: PublicCollectionChangelog
  "Time of when this revision was first created."
  createdAt: DateTime!
  "Time of when this revision was discarded."
  discardedAt: DateTime
  "The database ID for this revision."
  id: Int!
  "An average taken from all ratings for this revision"
  overallRating: String
  "A count of all ratings for this revision"
  overallRatingCount: Int
  "Average rating for a single revision and total number of votes"
  rating: AverageRating! @deprecated(reason: "Deprecated in favour of 'overallRating' and 'overallRatingCount'")
  "The revision number"
  revision: Int! @deprecated(reason: "Use `revision_number` instead.")
  "The revision number"
  revisionNumber: Int!
  "The status of this revision. Possible values are 'draft', 'published' or 'retracted'"
  revisionStatus: String!
  "Time of when this revision was last updated."
  updatedAt: DateTime!
}

"Autogenerated return type of PublishRevisionMutation."
type PublishRevisionMutationPayload {
  "Success Boolean"
  success: Boolean!
}

"Queries for fetching and filtering data"
type Query {
  "Gets age verification info for the authenticated user"
  ageVerificationInfo("The ID of the user to get age verification info for. If not provided, uses the authenticated user." userId: ID): AgeVerificationInfo!
  "Get a list of modding applications (accessed via API keys)"
  applications: [ApiApplication!]
  "Get a list of badges"
  badges: [Badge!]!
  "Get a list of the current user's ignored users."
  blockedAuthors: [User!] @deprecated(reason: "This endpoint will be replaced with ignored_users")
  "Get a list of the current user's blocked tags."
  blockedTags("If true, will only return non-adult tags" excludeAdult: Boolean): [LegacyTag!]
  "Get a list of categories"
  categories("Game ID" gameId: Int "If true, include all global categories" global: Boolean): [Category!]
  "Get a category by ID"
  category("Category ID" id: ID!): Category
  "Get a collection by slug"
  collection("Unique slug for a collection" slug: String "Overrides adult content in user preferences" viewAdultContent: Boolean "Specifies game domain. Will return a NOT_FOUND\n response if invalid domain is passed." domainName: String): Collection!
  "Get a list of Games containing 1 or more collections with the collection counts"
  collectionGames: [Game!]
  "Get a revision by collection slug and revision number"
  collectionRevision("Unique slug for a collection" slug: String "Revision number for collection.\n        If null, will return the latest published revision for this collection" revision: Int "Overrides adult content in user preferences" viewAdultContent: Boolean "Specifies game domain. Will return a NOT_FOUND\n response if invalid domain is passed." domainName: String): CollectionRevision!
  "Get a pre-signed upload URL for B2"
  collectionRevisionUploadUrl: PresignedUrl!
  "Get a list of collections"
  collectionsV2("Filter and aggregate by specified facets." facets: CollectionsFacet "View collections which you have blocked (e.g. via blocking authors)" viewUserBlockedContent: Boolean "Filter which restricts results and facets." filter: CollectionsSearchFilter "Filter which restricts results but not facets." postFilter: CollectionsSearchFilter sort: [CollectionsSearchSort!] offset: Int count: Int): CollectionPage!
  "Get a comment by its ID."
  comment("The database ID for this comment." commentId: ID!): Comment!
  "Get a comment thread by its ID."
  commentThread("The database ID for this comment thread." commentThreadId: ID!): CommentThread!
  "Get all CSAM Deletion Requests"
  csamDeletionRequests("Filter by status of the request" status: CsamDeletionRequestStatus "Secret key for CDNs to authenticate" cdnSecret: String): [CsamDeletionRequest!]!
  "Check MD5 hashes against the latest successful CSAM known image hashlist"
  csamHashCheck("Array of MD5 hashes to check against the CSAM hashlist" md5Hashes: [String!]!): [HashCheckResult!]!
  "Get a list of unread warnings for a user"
  currentWarnings: UserWarnings!
  "Gets an external video."
  externalVideo("The external video URL." url: String!): ExternalVideo!
  "Gets a user's favourite games"
  favouriteGames: [Game!]
  "Get Mod FileHash by md5"
  fileHash("MD5 file hashes for retrieving files" md5: String!): [FileHash!]!
  "Get a list of FileHashes"
  fileHashes("Array of MD5 file hashes for retrieving files in bulk" md5s: [String!]!): [FileHash!]
  "Get a Game by ID or domain name"
  game("Game ID to retrieve game for" id: ID "Game domain name to retrieve game for" domainName: String): Game
  "Get the current artwork schemas."
  gameArtwork: GameArtwork
  "Get a list of Games"
  games("Filter and aggregate by specified facets" facets: GamesFacet "Filter which restricts results and facets." filter: GamesSearchFilter "Filter which restricts results but not facets." postFilter: GamesSearchFilter sort: [GamesSearchSort!] offset: Int count: Int): GamePage!
  "Get a list of the current user's ignored users."
  ignoredUsers: [User!]
  "Get a list of the current user's ignored users."
  legacyBlockedAuthors: [User!] @deprecated(reason: "This is a legacy endpoint and should not be used.")
  "Get a list of mod using composite ids, with paging"
  legacyMods("Mod ID (Legacy format)" ids: [CompositeIdInput!]! offset: Int count: Int): ModPage!
  "Get a list of mods by domain_name and id, with paging"
  legacyModsByDomain("Get mod by legacy ID format" ids: [CompositeDomainWithIdInput!]! offset: Int count: Int): ModPage!
  "Fetches Mod Tags."
  legacyTags("If set, will show tags for a\n specific game ID. If nil, will only show global tags. Global tags are always included." gameId: ID "If true, will only return adult tags" onlyAdult: Boolean "If true, will only return non-adult tags" excludeAdult: Boolean): [LegacyTag!]
  "Get a list of media items (Images or Videos)"
  media("Filter and aggregate by specified facets" facets: MediaFacet "View media items which you have blocked (e.g. via blocking authors)" viewUserBlockedContent: Boolean filter: MediaSearchFilter postFilter: MediaSearchFilter sort: [MediaSearchSort!] offset: Int count: Int): MediaUnionPage!
  "Get a list of users that have endorsed a mod. Will return a maximum of 100 items per page."
  modEndorsers("Mod UID to retrieve endorsers for" modUid: ID! "Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): ModEndorserConnection!
  modFileContents(filter: ModFileContentSearchFilter sort: [ModFileContentSearchSort!] offset: Int count: Int): ModFileContentPage!
  "Get a list of mod files"
  modFiles("Mod ID for retrieving mods in bulk" modId: ID! "Game ID for retrieving mods in bulk" gameId: ID!): [ModFile!]!
  "Get a list of mod files by uid"
  modFilesByUid("List of Mod File UIDs (Not IDs) for retreiving mods in bulk" uids: [ID!]! offset: Int count: Int): ModFilePage!
  "Get a Moderation Reason by ID"
  moderationReason("The database ID for this moderation reason." id: ID!): ModerationReason
  "Get a list of Moderation Reasons"
  moderationReasons: [ModerationReason!]
  "Get a list of moderation warnings"
  moderationWarnings("Filter by a specific category" category: [ModerationWarningCategoryEnum!] "Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): ModerationWarningConnection
  "Get a list of mods, with paging"
  mods("View hidden mods that you are the uploader for (default: true)" viewUploaderHidden: Boolean "View mods which you have blocked (e.g. via blocking tags or authors)" viewUserBlockedContent: Boolean "Filter and aggregate by specified facets" facets: ModsFacet filter: ModsFilter postFilter: ModsFilter sort: [ModsSort!] offset: Int count: Int): ModPage!
  "Get a list of mods by uid, with paging"
  modsByUid("List of Mod UIDs (Not IDs) for retreiving mods in bulk" uids: [ID!]! offset: Int count: Int): ModPage!
  "Get a list of collections that the current user has access to view"
  myCollections("Filter and aggregate by specified facets" facets: CollectionsFacet "Alters the sorting column used for this query" sortBy: String "Alters the sorting direction used for this query" sortDirection: String "Overrides adult content in user preferences" viewAdultContent: Boolean "Shows unlisted collections (permission required)" viewUnlisted: Boolean "Shows moderated collections (permission required)" viewUnderModeration: Boolean "Filters the collections to a specific game." gameDomain: String @deprecated(reason: "DEPRECATED: Prefer to use filter.") "Filters the collections to a specific game." gameId: Int @deprecated(reason: "DEPRECATED: Prefer to use filter.") "Filters the collections to a specific category." categoryId: Int @deprecated(reason: "DEPRECATED: Prefer to use filter.") "Filter which restricts results and facets." filter: CollectionsFilter "Filter which restricts results but not facets." postFilter: CollectionsFilter offset: Int count: Int): CollectionPage! @deprecated(reason: "Deprecated- Use collectionsV2.")
  "retrieves all news articles."
  news("Filters the News to a specific news category." newsCategory: NewsCategoryEnum "Filters the News to a specific game." gameId: Int offset: Int count: Int): NewsPage!
  "Get a list of opted in mods for this user"
  optedInMods("ID of account for filtering" accountId: Int!): OptedInMods!
  "Get the personal API access key for a current user"
  personalApiKey: ApiKey
  "Get a list of user preferences for the current user"
  preferences: Preference
  "Get a private message URL"
  privateMessageUrl("Nexusmods ID of user to message" id: ID!): String
  "Get a pre-signed upload URL. You must supply EITHER mimeType (preferred) or filename."
  requestMediaUploadUrl("Local filename of the file to be uploaded. DEPRECATED- prefer mimeType." filename: String "MIME type of the file to be uploaded." mimeType: String): PresignedUrl!
  "Search comments by filter and sort criteria"
  searchComments(filter: CommentsSearchFilter sort: [CommentsSearchSort!] "Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int): CommentSearchResultConnection!
  "Get the urls for running a speedtest to diagnose download issues"
  speedtestUrls: [SpeedtestUrl!]!
  "Starts the age verification appeal flow for the current user."
  startAgeVerificationAppealFlow: StartAgeVerificationFlowResponse!
  "Starts the age verification flow for the current user."
  startAgeVerificationFlow: StartAgeVerificationFlowResponse!
  "Get a tag by ID"
  tag("ID of Tag Category to find" id: ID!): Tag
  "Get all tag categories"
  tagCategories: [TagCategory!]
  "Get a tag category by ID"
  tagCategory("ID of Tag Category to find" id: ID!): TagCategory
  "Get a list of tags"
  tags("Filter tags by a specific game ID" gameId: Int "Filter tags by a specific category ID" categoryId: Int "If true, will include all global tags" includeGlobal: Boolean "If true, will includes discarded tags" includeDiscarded: Boolean): [Tag!]
  "Get a list of transactions, with paging and filtering"
  transactions("Offset for pagination" start: Int "Number of elements to return per\npage" perPage: Int "Direction for sorting.\n'asc' or 'desc' are the only valid options" orderDir: String "Column used for sorting" orderColumn: String "Includes transactions involving this\nAccount's ID" accountId: Int "Includes transactions involving this\nBank's ID" bankId: Int "Filter transactions to return" search: String): TransactionList!
  "Get a list of uploads"
  uploads("For offset-based pagination. Indicates\nthe first element to start returning values from" start: Int! "Number of elements to return per\npage" perPage: Int! "Direction for sorting.\n'asc' or 'desc' are the only valid options" orderDir: String! "Column used for sorting" orderColumn: String! "The database ID for this ModUpload." id: String "Filter uploads" search: String "Filter uploads" filter: String "Only return specific types of uploads" uploadType: String "The database ID for this Game." gameId: Int "The database ID for this User." userId: Int "The database ID for this ModFile." fileId: Int "The database ID for this Mod." modId: Int): UploadList!
  "Get user by id"
  user("User ID of user to find" id: Int!): User
  "Get user by username"
  userByName("Username of user to find" name: String!): User
  "Get a list of user donation preferences."
  userDonationPreferences: LegacyUserDonationPreferences
  "Get monthly summary report for a specific user"
  userMonthlyReport("Account ID" accountId: Int! "Year report was generated" year: Int! "Month report was generated" month: Int!): UserMonthlyReport!
  "Get a specific report for a specific user"
  userMonthlyReportById("Account ID" accountId: Int! "Donation Report ID" reportId: Int!): UserMonthlyReport!
  "Get monthly summary report for a specific user"
  userMonthlySummary("Account ID" accountId: Int!): UserMonthlySummary!
  "Get a list of Users"
  users("Filter which restricts results." filter: UsersSearchFilter sort: [UsersSearchSort!] offset: Int count: Int): UserPage!
  "Get a list of wallets, with paging and filtering"
  wallets("For offset-based pagination. Indicates\nthe first element to start returning values from" start: Int "Number of elements to return per\npage" perPage: Int "Direction for sorting.\n'asc' or 'desc' are the only valid options" orderDir: String "Column used for sorting" orderColumn: String "Used to filter specific accounts" search: String): WalletList! @deprecated(reason: "Legacy Query. This endpoint may change or become unstable in future updates.")
}

input RandomSortValue {
  "If passed, randomness will be deterministic"
  seed: Int
}

"Ratable Model Types"
enum Ratable {
  "A nexusmods Collection of Mods"
  CollectionRevision
  "A Nexusmods Mod"
  Mod
}

"A Rating"
type Rating implements Node {
  "ID of the object."
  id: ID!
  "Polymorphic ID of the entity being rated"
  modelId: Int!
  "Polymorphic type of the entity being\nrated"
  modelType: String!
  "Rating value"
  rating: String!
  "ID of the user that created this rating"
  userId: Int!
}

"Rating options"
enum RatingOptions {
  positive
  negative
  abstained
}

"Autogenerated return type of RejectModerationFixMutation."
type RejectModerationFixMutationPayload {
  "Return the moderation fix object"
  moderationFix: ModerationFix!
  "Returns trus if the fix was rejected"
  success: Boolean!
}

"Autogenerated return type of RemoveBadgeFromCollectionMutation."
type RemoveBadgeFromCollectionMutationPayload {
  "True if badge was removed from the collection"
  success: Boolean!
}

"Autogenerated return type of RemoveCommentLikeMutation."
type RemoveCommentLikeMutationPayload {
  "The comment that had its like removed."
  comment: Comment!
}

"Autogenerated return type of RemoveFavouriteGameMutation."
type RemoveFavouriteGameMutationPayload {
  "True if the favourite was successfully removed"
  success: Boolean!
}

"Autogenerated return type of RemoveHeaderImageFromCollectionMutation."
type RemoveHeaderImageFromCollectionMutationPayload {
  "Returns true when image was removed successfully."
  success: Boolean!
}

"Autogenerated return type of RemoveImageFromCollectionMutation."
type RemoveImageFromCollectionMutationPayload {
  "Returns true when image is removed successfully."
  success: Boolean!
}

"Autogenerated return type of RemoveKudosMutation."
type RemoveKudosMutationPayload {
  "True if the user has successfully had kudos removed"
  success: Boolean!
}

"Autogenerated return type of RemoveTagFromCollectionMutation."
type RemoveTagFromCollectionMutationPayload {
  "Success Boolean"
  success: Boolean!
}

"Autogenerated return type of RemoveTileImageFromCollectionMutation."
type RemoveTileImageFromCollectionMutationPayload {
  "Returns true when image is removed successfully."
  success: Boolean!
}

"Autogenerated return type of RemoveVideoFromCollectionMutation."
type RemoveVideoFromCollectionMutationPayload {
  "Returns true when video is removed successfully."
  success: Boolean!
}

"Autogenerated return type of ReorderItem."
type ReorderItemPayload {
  "The item that was moved."
  item: Reorderable
}

"The relative location of an item in relation to another item."
enum ReorderLocation {
  "Before the item."
  BEFORE
  "After the item."
  AFTER
}

"Autogenerated return type of ReorderPinnedCommentsMutation."
type ReorderPinnedCommentsMutationPayload {
  "Pinned comments in a new order."
  comments: [Comment!]!
}

"A reorderable entity."
interface Reorderable {
  "The order of this entity in the list."
  order: String!
}

"Autogenerated return type of RestoreCommentMutation."
type RestoreCommentMutationPayload {
  "The comment that was restored."
  comment: Comment!
}

"Autogenerated return type of RetractRevisionMutation."
type RetractRevisionMutationPayload {
  "Success Boolean"
  success: Boolean!
}

"A reason for which a revision has been retracted."
type RetractionReason {
  "An immutable revision of a collection"
  collectionRevisionId: Int!
  "Time of when this retraction reason was first created."
  createdAt: DateTime!
  "The database ID for this retraction reason."
  id: Int!
  "User-provided reason for this retraction"
  reason: String!
  "Time of when this retraction reason was last updated."
  updatedAt: DateTime!
}

"Sort directions: ASC, DESC"
enum SortDirection {
  "Ascending"
  ASC
  "Descending"
  DESC
}

"A speedtest URL"
type SpeedtestUrl {
  "Description of this speedtest URL"
  description: String
  "URL of the resource"
  location: String
  "Tag of the resource"
  tag: String
  "Resource name of this speedtest URL"
  title: String
}

"The gql result of a query to the age verification flow start."
type StartAgeVerificationFlowResponse {
  "A message providing additional context about the request."
  message: String
  "True if the request to start the age verification flow was successful."
  success: Boolean!
  "The result of the age verification call."
  verificationResult: VerificationResult!
}

"Autogenerated return type of SubmitModerationFixMutation."
type SubmitModerationFixMutationPayload {
  "Return moderation fix object"
  moderationFix: ModerationFix!
  "Returns true if this fix was created successfully"
  success: Boolean!
}

"A supporter image"
type SupporterImage implements Node {
  "Whether comments are allowed on the image."
  allowComments: Boolean
  "Whether ratings are allowed on the image."
  allowRating: Boolean
  "A caption for this image"
  caption: String!
  "An image category"
  category: ImageCategory!
  "Time of when this supporter_image was first created."
  createdAt: DateTime!
  "A detailed description of this image"
  description: String!
  "Game this image belongs to"
  game: Game!
  "ID of the object."
  id: ID!
  "Status of this image"
  mediaStatus: MediaStatus!
  "Name of the image file"
  name: String!
  "Uploader of this image"
  owner: User!
  "Rating of this image"
  rating: Int!
  "URL of the site this image is hosted on"
  siteUrl: String!
  "URL of the thumbnail of this image"
  thumbnailUrl: String!
  "A title for this image"
  title: String
  "URL of this image"
  url: String!
  "True if the viewer (current user) has ignored this image's author"
  viewerBlocked: Boolean!
  "View count of this image"
  views: Int!
}

"The definition of a Tag Object. Deprecated.\nWill be removed in a future release in favour of domain specific tag queries\/mutations"
type Tag {
  "If true, this Tag is intended for adult content"
  adult: Boolean!
  "Category that this tag belongs to"
  category: TagCategory
  "Time of when this tag was first created."
  createdAt: DateTime!
  "Time of when this tag was discarded."
  discardedAt: DateTime
  "List of games that this tag is for"
  games: [Game!]
  "If true, this Tag is global and not intended for a specific game"
  global: Boolean!
  "The database ID for this tag."
  id: ID!
  "Name of this tag"
  name: String!
  "Number of tagged entities for this tag"
  taggablesCount: Int!
  "Time of when this tag was last updated."
  updatedAt: DateTime!
}

"The definition of a Tag Category Object. Deprecated.\nWill be removed in a future release in favour of domain specific tag queries\/mutations"
type TagCategory {
  "Time of when this tag category was first created."
  createdAt: DateTime!
  "Time of when this tag category was discarded."
  discardedAt: DateTime
  "The database ID for this tag category."
  id: ID!
  "Name of this Tag Category"
  name: String!
  "List of tags in this catgeory"
  tags: [Tag!]
  "Time of when this tag category was last updated."
  updatedAt: DateTime!
}

"Accepted Thumbnail Sizes"
enum ThumbnailSize {
  "250px width"
  small
  "385px width"
  med
  "500px width"
  large
}

"Autogenerated return type of TrackAppMetricMutation."
type TrackAppMetricMutationPayload {
  "The created metric event"
  appMetric: AppMetric
  "Any validation errors that occurred"
  errors: [String!]
  "Whether the metric was successfully tracked"
  success: Boolean!
}

"Autogenerated return type of TrackModMutation."
type TrackModMutationPayload {
  "True if the request to track the mod was successful, or if the mod was already tracked."
  success: Boolean!
  "Tracked mod entry."
  trackedMod: TrackedMod!
}

"Autogenerated return type of TrackUserMutation."
type TrackUserMutationPayload {
  "True if the request to track the user was successful"
  success: Boolean!
}

"Represents a user's tracking of a mod"
type TrackedMod {
  "The ID of the game that the tracked mod belongs to"
  gameId: ID!
  "The ID of the mod that is tracked"
  modId: ID!
  "The ID of the tracking user"
  userId: ID!
}

"A transaction"
type Transaction {
  "Amount of DP in this transaction"
  amount: Int!
  "Time of when this transaction was first created."
  createdAt: String!
  "Account\/Bank that DP is being sent to"
  creditor: String @deprecated(reason: "Use 'creditorEntity' instead")
  "Account\/Bank that DP is being sent to"
  creditorEntity: PaymentEntity
  "Account\/Bank that DP is being taken from"
  debitor: String @deprecated(reason: "Use 'debitorEntity' instead")
  "Account\/Bank that DP is being taken from"
  debitorEntity: PaymentEntity
  "The database ID for this transaction."
  id: Int!
  "Descriptive label for this transaction"
  label: String!
  "Type of transaction E.g. 'refund', 'purchase' etc"
  type: String!
}

"A list of transactions"
type TransactionList {
  "Number of transactions being filtered"
  filteredCount: Int!
  "Total number of transactions in the system"
  totalCount: Int!
  "List of Transactions"
  transactions: [Transaction!]
}

"Autogenerated return type of UnblockModsFromEarningDpMutation."
type UnblockModsFromEarningDpMutationPayload {
  "True if the mods were successfully unblocked"
  success: Boolean!
}

"Autogenerated return type of UnblockTagMutation."
type UnblockTagMutationPayload {
  "If true, the tag is unblocked."
  success: Boolean!
}

"Autogenerated return type of UnblockUserMutation."
type UnblockUserMutationPayload {
  "If true, the user is unignored."
  success: Boolean!
}

"Autogenerated return type of UnignoreUserMutation."
type UnignoreUserMutationPayload {
  "If true, the user is unignored."
  success: Boolean!
}

"Autogenerated return type of UnlistCollectionMutation."
type UnlistCollectionMutationPayload {
  "Success Boolean"
  success: Boolean!
}

"Autogenerated return type of UnpinCommentMutation."
type UnpinCommentMutationPayload {
  "The comment that was unpinned."
  comment: Comment!
}

"Autogenerated return type of UntrackModMutation."
type UntrackModMutationPayload {
  "True if the request to un-track the mod was successful, or if the mod was not being tracked."
  success: Boolean!
}

"Autogenerated return type of UntrackUserMutation."
type UntrackUserMutationPayload {
  "True if the request to stop tracking the user was successful"
  success: Boolean!
}

"Autogenerated return type of UpdateAboutMeMutation."
type UpdateAboutMeMutationPayload {
  "True if the bio was successfully updated"
  success: Boolean!
}

"Autogenerated return type of UpdateChangelogMutation."
type UpdateChangelogMutationPayload {
  "Updated Changelog ID"
  changelogId: Int!
  "Success Boolean"
  success: Boolean!
}

"Autogenerated return type of UpdateCollectionBugReportMutation."
type UpdateCollectionBugReportMutationPayload {
  "Collection bug report that was updated"
  collectionBugReport: CollectionBugReport!
}

"Autogenerated return type of UpdateCommentMutation."
type UpdateCommentMutationPayload {
  "The comment that was updated."
  comment: Comment!
}

"Autogenerated return type of UpdateCountryMutation."
type UpdateCountryMutationPayload {
  "True if the country was successfully updated"
  success: Boolean!
}

"Autogenerated return type of UpdateCsamDeletionRequest."
type UpdateCsamDeletionRequestPayload {
  "The updated CSAM Deletion Request"
  csamDeletionRequest: CsamDeletionRequest
}

"Autogenerated return type of UpdateGameMutation."
type UpdateGameMutationPayload {
  "If true, the game was updated"
  success: Boolean!
}

"Defines a Image Update request object"
input UpdateImageInput {
  "Image ID"
  id: ID!
  "Image title"
  title: String
  "Alternative text"
  altText: String
}

"Available update policies of a file resource"
enum UpdatePolicy {
  "Use the exact specified version"
  exact
  "Use the latest version"
  latest
  "Prefer the specified version if available"
  prefer
}

"Autogenerated return type of UpdateRevisionMutation."
type UpdateRevisionMutationPayload {
  "The revision ID that was updated"
  revisionId: Int!
  "If true, the revision was updated"
  success: Boolean!
}

"Autogenerated return type of UpdateTagMutation."
type UpdateTagMutationPayload {
  "Success Boolean"
  success: Boolean!
  "Updated Collection Tag"
  tag: Tag!
}

"Autogenerated return type of UpdateUserDonationPreferences."
type UpdateUserDonationPreferencesPayload {
  "If true, the user's preferences were updated."
  success: Boolean!
  "If successful, the user's updated donation preferences."
  userDonationPreferences: LegacyUserDonationPreferences
}

scalar Upload

"Autogenerated return type of UploadAttachmentMutation."
type UploadAttachmentMutationPayload {
  "The uploaded file returns a signed_id that can be used to attach to objects."
  attachment: Attachment!
}

"Autogenerated return type of UploadGameArtworkV2Mutation."
type UploadGameArtworkV2MutationPayload {
  "If true, the hero image was updated."
  successHero: Boolean!
  "If true, the thumbnail image was updated."
  successThumbnail: Boolean!
  "If true, the tile image was updated."
  successTile: Boolean!
}

"Defines a Image Upload request object"
input UploadImageInput {
  "Image UUID"
  id: ID!
  "Image content type"
  contentType: String!
  "Image title"
  title: String
  "Alternative text of the image"
  altText: String
}

"A list of upload"
type UploadList {
  "Number of uploads being filtered"
  filteredCount: Int!
  "Total number of uploads"
  totalCount: Int!
  "List of uploads"
  uploads: [ModUpload!]
}

"Defines a Video Upload request object"
input UploadVideoInput {
  "Video URL"
  url: String!
}

"A Nexus Mods user"
type User {
  "User's bio"
  about: String
  "The avatar for this user"
  avatar: String!
  "If true, this user has been banned"
  banned: Boolean!
  "Timestamp at which user's new mods were blocked from earning DP"
  blockedFromOptingInModsAt: DateTime
  "Number of collections uploaded by this user.\nThis does not include unlisted or moderated collections."
  collectionCount: Int!
  "The number of mods this user has contributed to"
  contributedModCount: Int!
  "ISO Country Code"
  country: String
  "If true, this user has been deleted"
  deleted: Boolean!
  "If true, this user has enabled donations on their profile page"
  donationsEnabled: Boolean!
  "If false, this user has specifically opted-out of the DP system. By default, all users are opted in."
  dpOptedIn: Boolean!
  "The user's email address. Users can only access their own protected data."
  email: String!
  "Number of mod endorsements given by this user"
  endorsementsGiven: Int!
  "The number of full page notifications this user has been served in the past."
  fullPageNotificationCount: Int
  "If true, the viewer (current user) has\ngiven kudos to this user."
  hasGivenKudos: Boolean!
  "Number of images uploaded by this user.\nThis does not include moderated images."
  imageCount: Int!
  "The user's last known IP Address. Users can only access their own protected data."
  ipAddress: String
  "If true, the viewer (current user) has\nblocked this user."
  isBlocked: Boolean!
  "If true, the viewer (current user) is\ntracking this user."
  isTracked: Boolean!
  "Date the user joined"
  joined: DateTime!
  "The number of 'kudos' given to this user"
  kudos: Int!
  "Date the user was last active"
  lastActive: DateTime
  "Legacy roles for this user. Returns an array of roles. E.g. \"[SiteProgrammer, QA Tester]\""
  legacyRoles: [String!]!
  "The database ID for this user."
  memberId: Int!
  "Membership status for this user. Returns an array of roles. E.g. all users are \"member\""
  membershipRoles: [String!]!
  "The analytics for the user's mods, grouped by month"
  modAnalyticsByMonth("The affiliation to filter by" affiliation: ModAffiliation "The page number to retrieve" page: Int "The number of results per page" pageSize: Int "The field to sort by" sortBy: ModAnalyticsByMonthSortBy "The direction to sort by" sortDirection: SortDirection): ModAnalyticsByMonthPage!
  "The analytics for the user's mods for a specific month"
  modAnalyticsForMonth("The year to retrieve analytics for" year: Int! "The month to retrieve analytics for" month: Int! "Search term to filter mods by" query: String "The affiliation to filter by" affiliation: ModAffiliation "The page number to retrieve" page: Int "The number of results per page" pageSize: Int "The field to sort by" sortBy: ModAnalyticsForMonthSortBy "The direction to sort by" sortDirection: SortDirection): ModAnalyticsForMonthPage!
  "Number of mods uploaded by this user.\nThis does not include hidden, moderated or unpublished mods."
  modCount: Int!
  "The number of moderation warnings this user has been served in the past."
  moderationHistoryCount: Int
  "JWT token for submitting moderation reports"
  moderationJwt: String!
  "A list of mods blocked from earning dp"
  modsBlockedFromEarningDp("Number of mods to return" count: Int "Number of mods to skip" offset: Int): BlockedModsPage!
  "The user's username."
  name: String!
  "The number of mods this user has uploaded"
  ownedModCount: Int!
  "Email address used for PayPal donations. Users can only access their own protected data."
  paypal: String
  "The number of forum posts by this user"
  posts: Int!
  "If true, this user is a\nrecognised mod author"
  recognizedAuthor: Boolean!
  "Roles for this user. Returns an array of roles. E.g. \"[Admin, Moderator]\""
  roles: [String!]!
  "If true, this user has opted to\nshow their activity feed on their user profile page"
  showActivityFeed: Boolean!
  "If true, this user has opted to\nshow the date they were last active on their user profile page"
  showLastActive: Boolean!
  "Number of unique mod downloads on this users mods"
  uniqueModDownloads: Int!
  "Date the user last\nchanged their username. Only users can access their own protected data."
  usernameLastChangedAt: DateTime
  "Number of videos uploaded by this user.\nThis does not include moderated videos."
  videoCount: Int!
  "Whether the viewer has blocked the content owner."
  viewerHasBlocked: Boolean
  "Whether the viewer has ignored the content owner."
  viewerHasIgnored: Boolean!
  "Number of profile views"
  views: Int!
}

"The connection type for User."
type UserConnection {
  "A list of edges."
  edges: [UserEdge]
  "A list of nodes."
  nodes: [User]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Total # of objects returned from this Plural Query"
  totalCount: Int!
}

"An edge in a connection."
type UserEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: User
}

"Monthly detailed report for for a particular user\/account\n    on how much DP\/downloads they have received for which mod\/game"
type UserMonthlyReport {
  "List of entries in this report"
  entries: [UserMonthlyReportEntry!]!
  "Type of report"
  reportType: DonationReport!
  "A Nexus Mods user"
  user: User
  "The database ID for this user."
  userId: Int!
}

"A more detailed entry for UserMonthlyReport, with a breakdown for a specific month for each mod"
type UserMonthlyReportEntry {
  "A Nexus Mods user"
  author: User
  "Number of authors that give this user DP"
  authorCount: Int
  "The database ID for this user."
  authorId: Int
  "Total DP value from all authors this user gets DP from, including DP not shared with this\nuser."
  authorValue: Int
  "A Game"
  game: Game
  "The database ID for this game."
  gameId: Int
  "A mod"
  mod: Mod
  "Number of mods that this user appears in"
  modCount: Int
  "The database ID for this mod."
  modId: Int
  "Total DP value from all mods this user appears in, including DP not shared with this user."
  modValue: Int
  "Month that this entry is for"
  month: Int!
  "Ratio of how much of the DP earned for a mod or author is given to this user"
  ratio: Float!
  "The database ID for this donation report."
  reportId: Int!
  "Opt-in status of this mod"
  status: Int!
  "Total DP granted to this user in this entry"
  value: Int!
  "Year that this entry is for"
  year: Int!
}

"Monthly summary for for a particular user\/account on how much DP\/downloads they have received"
type UserMonthlySummary {
  "List of summary report entries for this month"
  entries: [UserMonthlySummaryEntry!]!
  "A Nexus Mods user"
  user: User!
  "The database ID for this user."
  userId: Int!
}

"An entry for UserMonthlySummary, with a breakdown for a specific month"
type UserMonthlySummaryEntry {
  "Number of mods that this user appears in"
  modCount: Int!
  "Total DP value from all mods this user appears in, including DP not shared with this user."
  modValue: Int!
  "Month that this entry is for"
  month: Int!
  "Type of report"
  reportType: DonationReport!
  "Total DP granted to this user in this entry"
  value: Int!
  "Year that this entry is for"
  year: Int!
}

type UserPage {
  "Facets available, if supported for this query and requested."
  facets: [NodesFacet!]
  "Facets available, if supported for this query and requested. Schema is {\"facetName\":{\"facetValue\":count}}"
  facetsData: JSON
  "Nodes for pagination"
  nodes: [User!]!
  "Number of nodes returned by this query"
  nodesCount: Int!
  "Facets available, if supported for this query and requested."
  nodesFacets: [NodesFacet!]
  "String representation of the filter query used to locate the nodes."
  nodesFilter: String
  "Total number of collections found."
  totalCount: Int!
}

"A return type for the current warnings query"
type UserWarnings {
  "List of unread global notices"
  unreadGlobalNotices: [GlobalNotice!]!
  "List of unread warnings"
  unreadWarnings: [ModerationWarning!]!
}

"Filter fields specific to a Users query"
input UsersSearchFilter {
  "Nested filters."
  filter: [UsersSearchFilter!]
  "Logical operator for clauses."
  op: FilterLogicalOperator
  "Username."
  nameExact: [BaseFilterValueEqualsMatches!]
  "Username."
  nameWildcard: [BaseFilterValue!]
}

"Sort fields specific to a Users query."
input UsersSearchSort {
  "Filter query relevance, works best with non wildcard queries."
  relevance: BaseSortValue
  "username"
  name: BaseSortValue
}

"The result of a query to the age verification flow start from the API."
type VerificationResult {
  "Age verification flow ID, used to track the verification process"
  id: ID!
  "URL of the age verify widget to embed in the page"
  url: String!
}

"A video"
type Video implements Node {
  "Whether comments are allowed on the video."
  allowComments: Boolean
  "Whether ratings are allowed on the video."
  allowRating: Boolean
  "An video category"
  category: VideoCategory!
  "Time of when this video was first created."
  createdAt: DateTime!
  "The description of the video."
  description: String
  "Game this video belongs to"
  game: Game!
  "ID of the object."
  id: ID!
  "The URL of the video."
  link: String!
  "Status of this video"
  mediaStatus: MediaStatus!
  "Uploader of this video"
  owner: User!
  "The rating of the video."
  rating: Int!
  "URL of the site this video is hosted on"
  siteUrl: String!
  "The URL of the video thumbnail."
  thumbnailUrl: String!
  "The title of the video."
  title: String
  "True if the viewer (current user) has ignored this video's author"
  viewerBlocked: Boolean!
  "The number of views the video has."
  views: Int!
}

"An video category"
type VideoCategory {
  "Unix timestamp of category creation"
  date: Int
  "The database ID for this video category."
  id: ID!
  "Name of this category"
  name: String!
}

"Records the outcome of the virus scan for a mod file."
enum VirusScanStatus {
  NOT_SCANNED
  QUEUED
  WAITING_REPORT
  VERIFIED
  INTERNALLY_VERIFIED
  QUARANTINED
  MANUALLY_VERIFIED
  MOD_DOES_NOT_EXIST
  FILE_NOT_FOUND
  REPORT_ERROR
  TOO_LARGE
}

"A list of wallets. Users must have admin access."
type WalletList {
  "Number of wallets being filtered"
  filteredCount: Int!
  "Total number of wallets in the system"
  totalCount: Int!
}

"Autogenerated return type of WriteFullPageNotificationToUserMutation."
type WriteFullPageNotificationToUserMutationPayload {
  "Full page notification created successfully"
  success: Boolean
}

"Requires that exactly one field must be supplied and that field must not be `null`."
directive @oneOf on INPUT_OBJECT